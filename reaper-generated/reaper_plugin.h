// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
#pragma once

#include "CppSharp.h"
#include <include/reaper_plugin.h>
#include "reaper_plugin_functions.h"

namespace reaper_plugin_functions
{
    enum class PROJSTATECTX;
    enum class RAWMIDI;
    enum class SCREENSET_ACTION;
    ref class AcceleratorRegisterT;
    ref class ActionHelpT;
    ref class AudioHookRegisterT;
    ref class CustomActionRegisterT;
    ref class EditorRegisterT;
    ref class GaccelRegisterT;
    ref class IReaperControlSurface;
    ref class IReaperPitchShift;
    ref class ISimpleMediaDecoder;
    ref class KbdAccel;
    ref class KbdCmd;
    ref class KbdKeyBindingInfo;
    ref class KbdSectionInfo;
    ref class MIDI_event_t;
    ref class MIDI_eventlist;
    ref class MIDI_eventprops;
    ref class MediaItem;
    ref class MediaItemTake;
    ref class MediaTrack;
    ref class MidiInput;
    ref class MidiOutput;
    ref class MidiQuantizeModeT;
    ref class MidiRealtimeWriteStructT;
    ref class PCM_sink;
    ref class PCM_source;
    ref class PCM_source_peaktransfer_t;
    ref class PCM_source_transfer_t;
    ref class PcmsinkRegisterExtT;
    ref class PcmsinkRegisterT;
    ref class PcmsrcRegisterT;
    ref class PrefsPageRegisterT;
    ref class PreviewRegisterT;
    ref class ProjectConfigExtensionT;
    ref class ProjectImportRegisterT;
    ref class ProjectStateContext;
    ref class REAPER_PeakBuildInterface;
    ref class REAPER_PeakGetInterface;
    ref class REAPER_ResampleInterface;
    ref class REAPER_cue;
    ref class REAPER_inline_positioninfo;
    ref class REAPER_slice;
    ref class ReaProject;
    ref class ReaperCsurfRegT;
    ref class ReaperPluginInfoT;
    ref class TrackEnvelope;
}

namespace reaper_plugin_functions
{
    /// <summary>
    /// <para>**************************************************************************************</para>
    /// <para>*** interface for plugin objects to save/load state. they should use ../WDL/LineParser.h too...</para>
    /// <para>*************************************************************************************</para>
    /// </summary>
    // DEBUG: enum 
    // DEBUG: {
    // DEBUG:   PROJSTATECTX_UNDO_REDO=1,
    // DEBUG:   PROJSTATECTX_SAVE_LOAD=2, // project, track template, etc
    // DEBUG:   PROJSTATECTX_CUTCOPY_PASTE=3,
    // DEBUG: }
    public enum class PROJSTATECTX
    {
        PROJSTATECTX_UNDO_REDO = 1,
        PROJSTATECTX_SAVE_LOAD = 2,
        PROJSTATECTX_CUTCOPY_PASTE = 3
    };

    // DEBUG: enum { RAWMIDI_NOTESONLY=1, RAWMIDI_UNFILTERED=2 }
    public enum class RAWMIDI
    {
        RAWMIDI_NOTESONLY = 1,
        RAWMIDI_UNFILTERED = 2
    };

    // DEBUG: enum
    // DEBUG: {
    // DEBUG:   SCREENSET_ACTION_GETHWND = 0,
    // DEBUG: 
    // DEBUG:   SCREENSET_ACTION_IS_DOCKED = 1, // returns 1 if docked
    // DEBUG:   SCREENSET_ACTION_SWITCH_DOCK = 4, //dock if undocked and vice-versa
    // DEBUG: 
    // DEBUG:   SCREENSET_ACTION_LOAD_STATE=0x100, // load state from actionParm (of actionParmSize). if both are NULL, hide.
    // DEBUG:   SCREENSET_ACTION_SAVE_STATE,  // save state to actionParm, max length actionParmSize (will usually be 4k or greater), return length
    // DEBUG: }
    public enum class SCREENSET_ACTION
    {
        SCREENSET_ACTION_GETHWND = 0,
        SCREENSET_ACTION_IS_DOCKED = 1,
        SCREENSET_ACTION_SWITCH_DOCK = 4,
        SCREENSET_ACTION_LOAD_STATE = 256,
        SCREENSET_ACTION_SAVE_STATE = 257
    };

    // DEBUG: typedef LRESULT (*screensetNewCallbackFunc)(int action, const char *id, void *param, void *actionParm, int actionParmSize)
    [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
    public delegate long long ScreensetNewCallbackFunc(int action, System::String^ id, ::System::IntPtr param, ::System::IntPtr actionParm, int actionParmSize);

    // DEBUG: struct reaper_plugin_info_t
    // DEBUG: {
    // DEBUG:   int caller_version; // REAPER_PLUGIN_VERSION
    // DEBUG: 
    // DEBUG:   HWND hwnd_main;
    // DEBUG: 
    // DEBUG:   /*
    // DEBUG:   Register() is the API that plug-ins register most things, be it keyboard shortcuts, project importers, etc.
    // DEBUG:   Register() is also available by using GetFunc("plugin_register")
    // DEBUG: 
    // DEBUG:   extensions typically register things on load of the DLL, for example:
    // DEBUG: 
    // DEBUG:      static pcmsink_register_t myreg={ ... };
    // DEBUG:      rec->Register("pcmsink",&myreg);
    // DEBUG: 
    // DEBUG:   on plug-in unload (or if the extension wishes to remove it for some reason):
    // DEBUG:      rec->Register("-pcmsink",&myreg);
    // DEBUG: 
    // DEBUG:   the "-" prefix is supported for most registration types.
    // DEBUG:   some types support the < prefix to register at the start of the list
    // DEBUG: 
    // DEBUG:   Registration types:
    // DEBUG: 
    // DEBUG:   API_*:
    // DEBUG:     if you have a function called myfunction(..) that you want to expose to other extensions, use:
    // DEBUG:       rec->Register("API_myfunction",funcaddress);
    // DEBUG:     other extensions then use GetFunc("myfunction") to get the function pointer.
    // DEBUG: 
    // DEBUG:   APIdef_*:
    // DEBUG:     To make a function registered with API_* available via ReaScript, follow the API_ registration with:
    // DEBUG:       double myfunction(char* str, int flag);
    // DEBUG:       const char *defstring = "double\0char*,int\0str,flag\0help text for myfunction"
    // DEBUG:       rec->Register("APIdef_myfunction",(void*)defstring);
    // DEBUG:     defstring is four null-separated fields: return type, argument types, argument names, and help.
    // DEBUG: 
    // DEBUG:   APIvararg_*:
    // DEBUG:     Used to set the reascript vararg function pointer for an API_. todo document
    // DEBUG: 
    // DEBUG:   hookcommand:
    // DEBUG:     Registers a hook which runs prior to every action in the main section:
    // DEBUG:       bool runCommand(int command, int flag);
    // DEBUG:       rec->Register("hookcommand",runCommand);
    // DEBUG:     runCommand() should return true if it processed the command (prevent further hooks or the action from running)
    // DEBUG:     It is OK to call Main_OnCommand() from runCommand(), but it must check for and handle any recursion.
    // DEBUG: 
    // DEBUG:   hookpostcommand:
    // DEBUG:     Registers a hook which runs after each action in the main section:
    // DEBUG:       void postCommand(int command, int flag);
    // DEBUG:       rec->Register("hookpostcommand",postCommand);
    // DEBUG: 
    // DEBUG:   hookcommand2:
    // DEBUG:     Registers a hook which runs prior to every action triggered by a key/MIDI event:
    // DEBUG:       bool onAction(KbdSectionInfo *sec, int command, int val, int val2, int relmode, HWND hwnd);
    // DEBUG:       rec->Register("hookcommand2",hook); \
    // DEBUG:     onAction returns true if it processed the command (preventing further hooks or actions from running)
    // DEBUG:       val/val2 are used for actions triggered by MIDI/OSC/mousewheel
    // DEBUG:         - val = [0..127] and val2 = -1 for MIDI CC,
    // DEBUG:         - val2 >=0 for MIDI pitch or OSC with value = (val2|(val<<7))/16383.0
    // DEBUG:         - relmode absolute(0) or 1/2/3 for relative adjust modes
    // DEBUG: 
    // DEBUG:   hookpostcommand2:
    // DEBUG:      void (*hook)(KbdSectionInfo *section, int actionCommandID, int val, int valhw, int relmode, HWND hwnd, ReaProject *proj);
    // DEBUG:      rec->Register("hookpostcommand2",hook);
    // DEBUG: 
    // DEBUG:   command_id:
    // DEBUG:     Registers/looks up a command ID for an action. Parameter is a unique string with only A-Z, a-z, 0-9.
    // DEBUG:       int command = Register("command_id","MyCommandName");
    // DEBUG:     returns 0 if unsupported/out of actions
    // DEBUG: 
    // DEBUG:   command_id_lookup:
    // DEBUG:     Like command_id but only looks up, does not create a new command ID.
    // DEBUG: 
    // DEBUG:   pcmsink_ext:
    // DEBUG:     Registers an extended audio sink type:
    // DEBUG:       (pcmsink_register_ext_t *)
    // DEBUG: 
    // DEBUG:   pcmsink:
    // DEBUG:     Registers an audio sink type:
    // DEBUG:       (pcmsink_register_t *)
    // DEBUG: 
    // DEBUG:   pcmsrc:
    // DEBUG:     Registers an audio source:
    // DEBUG:     (pcmsrc_register_t *)
    // DEBUG: 
    // DEBUG:   timer:
    // DEBUG:     Runs a timer periodically:
    // DEBUG:       void (*timer_function)();
    // DEBUG: 
    // DEBUG:   file_in_project_ex:
    // DEBUG:   accel_section:
    // DEBUG:   action_help:
    // DEBUG:   custom_action:
    // DEBUG:   gaccel:
    // DEBUG:   hookcustommenu:
    // DEBUG:   prefpage:
    // DEBUG:   projectimport:
    // DEBUG:   projectconfig:
    // DEBUG:   editor:
    // DEBUG:   accelerator:
    // DEBUG:   csurf:
    // DEBUG:   csurf_inst:
    // DEBUG:   toggleaction:
    // DEBUG:   on_update_hooks:
    // DEBUG:   toolbar_icon_map:
    // DEBUG:   open_file_reduce:
    // DEBUG: 
    // DEBUG:   */
    // DEBUG: 
    // DEBUG:   int (*Register)(const char *name, void *infostruct); // returns 1 if registered successfully
    // DEBUG: 
    // DEBUG:   // get a generic API function, there many of these defined. see reaper_plugin_functions.h
    // DEBUG:   void * (*GetFunc)(const char *name); // returns 0 if function not found
    // DEBUG: 
    // DEBUG: }
    public ref class ReaperPluginInfoT : ICppInstance
    {
    public:

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate int Func_int_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string___IntPtr(System::String^ name, ::System::IntPtr infostruct);

        property ::reaper_plugin_info_t* NativePtr;
        property System::IntPtr __Instance
        {
            virtual System::IntPtr get();
            virtual void set(System::IntPtr instance);
        }

        ReaperPluginInfoT(::reaper_plugin_info_t* native);
        ReaperPluginInfoT(::reaper_plugin_info_t* native, bool ownNativeInstance);
        static ReaperPluginInfoT^ __CreateInstance(::System::IntPtr native);
        static ReaperPluginInfoT^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
        // DEBUG: reaper_plugin_info_t
        ReaperPluginInfoT();

        // DEBUG: reaper_plugin_info_t
        ReaperPluginInfoT(reaper_plugin_functions::ReaperPluginInfoT^ _0);

        ~ReaperPluginInfoT();

        property int CallerVersion
        {
            int get();
            void set(int);
        }

        property HWND_^ HwndMain
        {
            HWND_^ get();
            void set(HWND_^);
        }

        property reaper_plugin_functions::ReaperPluginInfoT::Func_int_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string___IntPtr^ Register
        {
            reaper_plugin_functions::ReaperPluginInfoT::Func_int_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string___IntPtr^ get();
            void set(reaper_plugin_functions::ReaperPluginInfoT::Func_int_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string___IntPtr^);
        }

        property ::reaper_plugin_functions::Func___IntPtr_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string^ GetFunc
        {
            ::reaper_plugin_functions::Func___IntPtr_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string^ get();
            void set(::reaper_plugin_functions::Func___IntPtr_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string^);
        }

    protected:

        bool __ownsNativeInstance;
    };

    // DEBUG: class ProjectStateContext // this is also defined in WDL, need to keep these interfaces identical
    // DEBUG: {
    // DEBUG: public:
    // DEBUG:   virtual ~ProjectStateContext(){};
    // DEBUG: 
    // DEBUG: #ifdef __GNUC__
    // DEBUG:   virtual void  __attribute__ ((format (printf,2,3))) AddLine(const char *fmt, ...) = 0;
    // DEBUG: #else
    // DEBUG:   virtual void AddLine(const char *fmt, ...)=0;
    // DEBUG: #endif
    // DEBUG:   virtual int GetLine(char *buf, int buflen)=0; // returns -1 on eof
    // DEBUG: 
    // DEBUG:   virtual INT64 GetOutputSize()=0; // output size written so far, only usable on REAPER 3.14+
    // DEBUG: 
    // DEBUG:   virtual int GetTempFlag()=0;
    // DEBUG:   virtual void SetTempFlag(int flag)=0;
    // DEBUG: }
    public ref class ProjectStateContext : ICppInstance
    {
    public:

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate void Action___IntPtr_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string(::System::IntPtr __instance, System::String^ arg1);

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate int Func_int___IntPtr_sbytePtr_int(::System::IntPtr __instance, char* arg1, int arg2);

        property ::ProjectStateContext* NativePtr;
        property System::IntPtr __Instance
        {
            virtual System::IntPtr get();
            virtual void set(System::IntPtr instance);
        }

        ProjectStateContext(::ProjectStateContext* native);
        ProjectStateContext(::ProjectStateContext* native, bool ownNativeInstance);
        static ProjectStateContext^ __CreateInstance(::System::IntPtr native);
        static ProjectStateContext^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
        // DEBUG: ProjectStateContext
        ProjectStateContext();

        // DEBUG: ProjectStateContext
        ProjectStateContext(reaper_plugin_functions::ProjectStateContext^ _0);

        ~ProjectStateContext();

        property long long OutputSize
        {
            long long get();
        }

        property int TempFlag
        {
            int get();
            void set(int);
        }

        // DEBUG: virtual void AddLine(const char *fmt, ...)=0
        virtual void AddLine(System::String^ fmt);

        // DEBUG: virtual int GetLine(char *buf, int buflen)=0
        virtual int GetLine(char* buf, int buflen);

    protected:

        bool __ownsNativeInstance;
    };

    /// <summary>
    /// <para>*************************************************************************************</para>
    /// <para>*** MIDI event definition and abstract list</para>
    /// <para>*************************************************************************************</para>
    /// </summary>
    // DEBUG: struct MIDI_event_t
    // DEBUG: {
    // DEBUG:   int frame_offset;
    // DEBUG:   int size; // bytes used by midi_message, can be >3, but should never be <3, even if a short 1 or 2 byte msg
    // DEBUG:   unsigned char midi_message[4]; // size is number of bytes valid -- can be more than 4!
    // DEBUG: 
    // DEBUG:   // new helpers
    // DEBUG:   bool is_note() const { return (midi_message[0]&0xe0)==0x80; }
    // DEBUG:   bool is_note_on() const {
    // DEBUG:     return (midi_message[0]&0xf0)==0x90 && midi_message[2];
    // DEBUG:   }
    // DEBUG:   bool is_note_off() const {
    // DEBUG:     switch (midi_message[0]&0xf0)
    // DEBUG:     {
    // DEBUG:       case 0x80: return true;
    // DEBUG:       case 0x90: return midi_message[2]==0;
    // DEBUG:     }
    // DEBUG:     return false;
    // DEBUG:   }
    // DEBUG: }
    public ref class MIDI_event_t : ICppInstance
    {
    public:

        property ::MIDI_event_t* NativePtr;
        property System::IntPtr __Instance
        {
            virtual System::IntPtr get();
            virtual void set(System::IntPtr instance);
        }

        MIDI_event_t(::MIDI_event_t* native);
        MIDI_event_t(::MIDI_event_t* native, bool ownNativeInstance);
        static MIDI_event_t^ __CreateInstance(::System::IntPtr native);
        static MIDI_event_t^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
        // DEBUG: MIDI_event_t
        MIDI_event_t();

        // DEBUG: MIDI_event_t
        MIDI_event_t(reaper_plugin_functions::MIDI_event_t^ _0);

        ~MIDI_event_t();

        property int FrameOffset
        {
            int get();
            void set(int);
        }

        property int Size
        {
            int get();
            void set(int);
        }

        property cli::array<unsigned char>^ MidiMessage
        {
            cli::array<unsigned char>^ get();
            void set(cli::array<unsigned char>^);
        }

        property bool IsNote
        {
            bool get();
        }

        property bool IsNoteOn
        {
            bool get();
        }

        property bool IsNoteOff
        {
            bool get();
        }

    protected:

        bool __ownsNativeInstance;
    };

    // DEBUG: class MIDI_eventlist
    // DEBUG: {
    // DEBUG: public:
    // DEBUG:   virtual void AddItem(MIDI_event_t *evt)=0;
    // DEBUG:   virtual MIDI_event_t *EnumItems(int *bpos)=0; 
    // DEBUG:   virtual void DeleteItem(int bpos)=0;
    // DEBUG:   virtual int GetSize()=0; // size of block in bytes
    // DEBUG:   virtual void Empty()=0;
    // DEBUG: 
    // DEBUG: protected:
    // DEBUG:   // this is only defined in REAPER 4.60+, for 4.591 and earlier you should delete only via the implementation pointer
    // DEBUG:   virtual ~MIDI_eventlist() { }
    // DEBUG: }
    public ref class MIDI_eventlist : ICppInstance
    {
    public:

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate reaper_plugin_functions::MIDI_event_t^ Func___IntPtr___IntPtr_intPtr(::System::IntPtr __instance, [System::Runtime::InteropServices::In, System::Runtime::InteropServices::Out] int% arg1);

        property ::MIDI_eventlist* NativePtr;
        property System::IntPtr __Instance
        {
            virtual System::IntPtr get();
            virtual void set(System::IntPtr instance);
        }

        MIDI_eventlist(::MIDI_eventlist* native);
        MIDI_eventlist(::MIDI_eventlist* native, bool ownNativeInstance);
        static MIDI_eventlist^ __CreateInstance(::System::IntPtr native);
        static MIDI_eventlist^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
        // DEBUG: MIDI_eventlist
        MIDI_eventlist();

        // DEBUG: MIDI_eventlist
        MIDI_eventlist(reaper_plugin_functions::MIDI_eventlist^ _0);

        property int Size
        {
            int get();
        }

        // DEBUG: virtual void AddItem(MIDI_event_t *evt)=0
        virtual void AddItem(reaper_plugin_functions::MIDI_event_t^ evt);

        // DEBUG: virtual MIDI_event_t *EnumItems(int *bpos)=0
        virtual reaper_plugin_functions::MIDI_event_t^ EnumItems([System::Runtime::InteropServices::In, System::Runtime::InteropServices::Out] int% bpos);

        // DEBUG: virtual void DeleteItem(int bpos)=0
        virtual void DeleteItem(int bpos);

        // DEBUG: virtual void Empty()=0
        virtual void Empty();

    protected:

        bool __ownsNativeInstance;
    };

    // DEBUG: struct
    // DEBUG: {
    // DEBUG:   double ppqpos;
    // DEBUG:   double ppqpos_end_or_bezier_tension; // only for note events or CC events
    // DEBUG:   char flag; // &1=selected, &2=muted, >>4&0xF=cc shape
    // DEBUG:   unsigned char msg[3]; // msg is not valid if varmsglen > 0
    // DEBUG:   char* varmsg;
    // DEBUG:   int varmsglen;
    // DEBUG:   int setflag; // &1:selected, &2:muted, &4:ppqpos, &8:endppqpos or bez tension, &16:msg1 high bits, &32:msg1 low bits, &64:msg2, &128:msg3, &256:varmsg, &1024:shape/tension fields used, &16384:no sort after set
    // DEBUG: }
    public ref class MIDI_eventprops : ICppInstance
    {
    public:

        property ::MIDI_eventprops* NativePtr;
        property System::IntPtr __Instance
        {
            virtual System::IntPtr get();
            virtual void set(System::IntPtr instance);
        }

        MIDI_eventprops(::MIDI_eventprops* native);
        MIDI_eventprops(::MIDI_eventprops* native, bool ownNativeInstance);
        static MIDI_eventprops^ __CreateInstance(::System::IntPtr native);
        static MIDI_eventprops^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
        // DEBUG: struct
        MIDI_eventprops();

        // DEBUG: struct
        MIDI_eventprops(reaper_plugin_functions::MIDI_eventprops^ __0);

        ~MIDI_eventprops();

        property double Ppqpos
        {
            double get();
            void set(double);
        }

        property double PpqposEndOrBezierTension
        {
            double get();
            void set(double);
        }

        property char Flag
        {
            char get();
            void set(char);
        }

        property cli::array<unsigned char>^ Msg
        {
            cli::array<unsigned char>^ get();
            void set(cli::array<unsigned char>^);
        }

        property char* Varmsg
        {
            char* get();
            void set(char*);
        }

        property int Varmsglen
        {
            int get();
            void set(int);
        }

        property int Setflag
        {
            int get();
            void set(int);
        }

    protected:

        bool __ownsNativeInstance;
    };

    /// <summary>
    /// <para>*************************************************************************************</para>
    /// <para>*** PCM source API</para>
    /// <para>*************************************************************************************</para>
    /// </summary>
    // DEBUG: struct
    // DEBUG: {
    // DEBUG:   double time_s; // start time of block
    // DEBUG: 
    // DEBUG:   double samplerate; // desired output samplerate and channels
    // DEBUG:   int nch;
    // DEBUG: 
    // DEBUG:   int length; // desired length in sample(pair)s of output
    // DEBUG: 
    // DEBUG:   ReaSample *samples; // samples filled in (the caller allocates this)
    // DEBUG:   int samples_out; // updated with number of sample(pair)s actually rendered
    // DEBUG: 
    // DEBUG:   MIDI_eventlist *midi_events;
    // DEBUG: 
    // DEBUG:   double approximate_playback_latency; // 0.0 if not supported
    // DEBUG:   double absolute_time_s;
    // DEBUG:   double force_bpm;
    // DEBUG: }
    public ref class PCM_source_transfer_t : ICppInstance
    {
    public:

        property ::PCM_source_transfer_t* NativePtr;
        property System::IntPtr __Instance
        {
            virtual System::IntPtr get();
            virtual void set(System::IntPtr instance);
        }

        PCM_source_transfer_t(::PCM_source_transfer_t* native);
        PCM_source_transfer_t(::PCM_source_transfer_t* native, bool ownNativeInstance);
        static PCM_source_transfer_t^ __CreateInstance(::System::IntPtr native);
        static PCM_source_transfer_t^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
        // DEBUG: struct
        PCM_source_transfer_t();

        // DEBUG: struct
        PCM_source_transfer_t(reaper_plugin_functions::PCM_source_transfer_t^ __0);

        ~PCM_source_transfer_t();

        property double TimeS
        {
            double get();
            void set(double);
        }

        property double Samplerate
        {
            double get();
            void set(double);
        }

        property int Nch
        {
            int get();
            void set(int);
        }

        property int Length
        {
            int get();
            void set(int);
        }

        property double* Samples
        {
            double* get();
            void set(double*);
        }

        property int SamplesOut
        {
            int get();
            void set(int);
        }

        property reaper_plugin_functions::MIDI_eventlist^ MidiEvents
        {
            reaper_plugin_functions::MIDI_eventlist^ get();
            void set(reaper_plugin_functions::MIDI_eventlist^);
        }

        property double ApproximatePlaybackLatency
        {
            double get();
            void set(double);
        }

        property double AbsoluteTimeS
        {
            double get();
            void set(double);
        }

        property double ForceBpm
        {
            double get();
            void set(double);
        }

    protected:

        bool __ownsNativeInstance;
    };

    // DEBUG: struct
    // DEBUG: {
    // DEBUG:   double start_time; // start time of block
    // DEBUG:   double peakrate;   // peaks per second (see samplerate below)
    // DEBUG: 
    // DEBUG:   int numpeak_points; // desired number of points for data
    // DEBUG: 
    // DEBUG:   int nchpeaks; // number of channels of peaks data requested
    // DEBUG: 
    // DEBUG:   ReaSample *peaks;  // peaks output (caller allocated)
    // DEBUG:   int peaks_out; // number of points actually output (less than desired means at end)
    // DEBUG: 
    // DEBUG:   enum 
    // DEBUG:   { 
    // DEBUG:     PEAKTRANSFER_PEAKS_MODE=0, 
    // DEBUG:     PEAKTRANSFER_WAVEFORM_MODE=1, 
    // DEBUG:     PEAKTRANSFER_MIDI_NOTE_MODE=2,
    // DEBUG:     PEAKTRANSFER_MIDI_DRUM_MODE=3,
    // DEBUG:     PEAKTRANSFER_MIDI_DRUM_TRIANGLE_MODE=4,
    // DEBUG:   };
    // DEBUG:   int output_mode; // see enum above
    // DEBUG: 
    // DEBUG:   double absolute_time_s;
    // DEBUG: 
    // DEBUG:   ReaSample *peaks_minvals; // can be NULL, otherwise receives minimum values
    // DEBUG:   int peaks_minvals_used;
    // DEBUG: 
    // DEBUG:   double samplerate; // peakrate is peaks per second, samplerate is used only as a hint for what style of peaks to draw, OK to pass in zero
    // DEBUG: 
    // DEBUG: #define PEAKINFO_EXTRADATA_SPECTRAL1 ((int)'s')
    // DEBUG: #define PEAKINFO_EXTRADATA_SPECTROGRAM1 ((int)'g')
    // DEBUG: #define PEAKINFO_EXTRADATA_MIDITEXT ((int)'m')
    // DEBUG:   int extra_requested_data_type; // PEAKINFO_EXTRADATA_* for spectral information
    // DEBUG:   int extra_requested_data_out; // output: number of samples returned (== peaks_out if successful)
    // DEBUG:   void *extra_requested_data;
    // DEBUG: 
    // DEBUG:   REAPER_PeakGet_Interface *__peakgetter;
    // DEBUG: #ifdef __LP64__
    // DEBUG:   int *exp[27];
    // DEBUG: #else
    // DEBUG:   int *exp[26];
    // DEBUG: #endif
    // DEBUG: 
    // DEBUG:   static inline int extra_blocksize(int extra_requested_data_type)
    // DEBUG:   {
    // DEBUG:     switch (extra_requested_data_type) 
    // DEBUG:     {
    // DEBUG:       case PEAKINFO_EXTRADATA_SPECTRAL1: return sizeof(int); // one int per channel per sample spectral info: low 15 bits frequency, next 14 bits density (16383=tonal, 0=noise, 12288 = a bit noisy)
    // DEBUG:       case PEAKINFO_EXTRADATA_SPECTROGRAM1: return SPECTROGRAM1_BLOCKSIZE_BYTES;
    // DEBUG:       case PEAKINFO_EXTRADATA_MIDITEXT: return 1; // at most one character per pixel
    // DEBUG:     }
    // DEBUG:     return 0;
    // DEBUG:   }
    // DEBUG:   enum { SPECTROGRAM1_BLOCKSIZE_BYTES=128 * 3 / 2 }; // 128 bins, 12 bits each (MSB1, (LSN1<<4)|LSN2, MSB2)
    // DEBUG: 
    // DEBUG: }
    public ref class PCM_source_peaktransfer_t : ICppInstance
    {
    public:

        // DEBUG: enum 
        // DEBUG:   { 
        // DEBUG:     PEAKTRANSFER_PEAKS_MODE=0, 
        // DEBUG:     PEAKTRANSFER_WAVEFORM_MODE=1, 
        // DEBUG:     PEAKTRANSFER_MIDI_NOTE_MODE=2,
        // DEBUG:     PEAKTRANSFER_MIDI_DRUM_MODE=3,
        // DEBUG:     PEAKTRANSFER_MIDI_DRUM_TRIANGLE_MODE=4,
        // DEBUG:   }
        enum class PEAKTRANSFER
        {
            PEAKTRANSFER_PEAKS_MODE = 0,
            PEAKTRANSFER_WAVEFORM_MODE = 1,
            PEAKTRANSFER_MIDI_NOTE_MODE = 2,
            PEAKTRANSFER_MIDI_DRUM_MODE = 3,
            PEAKTRANSFER_MIDI_DRUM_TRIANGLE_MODE = 4
        };

        // DEBUG: enum { SPECTROGRAM1_BLOCKSIZE_BYTES=128 * 3 / 2 }
        enum class SPECTROGRAM1BLOCKSIZE_BYTES
        {
            SPECTROGRAM1_BLOCKSIZE_BYTES = 192
        };

        property ::PCM_source_peaktransfer_t* NativePtr;
        property System::IntPtr __Instance
        {
            virtual System::IntPtr get();
            virtual void set(System::IntPtr instance);
        }

        PCM_source_peaktransfer_t(::PCM_source_peaktransfer_t* native);
        PCM_source_peaktransfer_t(::PCM_source_peaktransfer_t* native, bool ownNativeInstance);
        static PCM_source_peaktransfer_t^ __CreateInstance(::System::IntPtr native);
        static PCM_source_peaktransfer_t^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
        // DEBUG: struct
        PCM_source_peaktransfer_t();

        // DEBUG: struct
        PCM_source_peaktransfer_t(reaper_plugin_functions::PCM_source_peaktransfer_t^ __0);

        ~PCM_source_peaktransfer_t();

        property double StartTime
        {
            double get();
            void set(double);
        }

        property double Peakrate
        {
            double get();
            void set(double);
        }

        property int NumpeakPoints
        {
            int get();
            void set(int);
        }

        property int Nchpeaks
        {
            int get();
            void set(int);
        }

        property double* Peaks
        {
            double* get();
            void set(double*);
        }

        property int PeaksOut
        {
            int get();
            void set(int);
        }

        property int OutputMode
        {
            int get();
            void set(int);
        }

        property double AbsoluteTimeS
        {
            double get();
            void set(double);
        }

        property double* PeaksMinvals
        {
            double* get();
            void set(double*);
        }

        property int PeaksMinvalsUsed
        {
            int get();
            void set(int);
        }

        property double Samplerate
        {
            double get();
            void set(double);
        }

        property int ExtraRequestedDataType
        {
            int get();
            void set(int);
        }

        property int ExtraRequestedDataOut
        {
            int get();
            void set(int);
        }

        property ::System::IntPtr ExtraRequestedData
        {
            ::System::IntPtr get();
            void set(::System::IntPtr);
        }

        property reaper_plugin_functions::REAPER_PeakGetInterface^ Peakgetter
        {
            reaper_plugin_functions::REAPER_PeakGetInterface^ get();
            void set(reaper_plugin_functions::REAPER_PeakGetInterface^);
        }

        property cli::array<int*>^ Exp
        {
            cli::array<int*>^ get();
            void set(cli::array<int*>^);
        }

        // DEBUG: static inline int extra_blocksize(int extra_requested_data_type)
        // DEBUG:   {
        // DEBUG:     switch (extra_requested_data_type) 
        // DEBUG:     {
        // DEBUG:       case PEAKINFO_EXTRADATA_SPECTRAL1: return sizeof(int); // one int per channel per sample spectral info: low 15 bits frequency, next 14 bits density (16383=tonal, 0=noise, 12288 = a bit noisy)
        // DEBUG:       case PEAKINFO_EXTRADATA_SPECTROGRAM1: return SPECTROGRAM1_BLOCKSIZE_BYTES;
        // DEBUG:       case PEAKINFO_EXTRADATA_MIDITEXT: return 1; // at most one character per pixel
        // DEBUG:     }
        // DEBUG:     return 0;
        // DEBUG:   }
        static int ExtraBlocksize(int extra_requested_data_type);

    protected:

        bool __ownsNativeInstance;
    };

    // DEBUG: struct
    // DEBUG: {
    // DEBUG:   double global_time;
    // DEBUG:   double global_item_time;
    // DEBUG:   double srate;
    // DEBUG:   int length; // length in samples
    // DEBUG:   int overwritemode; // 0=overdub, 1=replace, 
    // DEBUG:                      // -1 = literal (do nothing just add)
    // DEBUG:                      // 65536+(16 bit mask) = replace notes on just these channels (touch-replace)
    // DEBUG:   MIDI_eventlist *events;
    // DEBUG:   double item_playrate;
    // DEBUG: 
    // DEBUG:   double latency;
    // DEBUG: 
    // DEBUG:   unsigned int *overwrite_actives; // [16(note)+16(CC)+16(poly AT)][4]; only used when overwritemode is >0
    // DEBUG:                                    // CC: 127=pitch, 126=program, 125=channel pressure
    // DEBUG: 
    // DEBUG:   double do_not_quantize_past_sec; // amount in future that quantizing should never move things past (or 0 for not used)
    // DEBUG: }
    public ref class MidiRealtimeWriteStructT : ICppInstance
    {
    public:

        property ::midi_realtime_write_struct_t* NativePtr;
        property System::IntPtr __Instance
        {
            virtual System::IntPtr get();
            virtual void set(System::IntPtr instance);
        }

        MidiRealtimeWriteStructT(::midi_realtime_write_struct_t* native);
        MidiRealtimeWriteStructT(::midi_realtime_write_struct_t* native, bool ownNativeInstance);
        static MidiRealtimeWriteStructT^ __CreateInstance(::System::IntPtr native);
        static MidiRealtimeWriteStructT^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
        // DEBUG: struct
        MidiRealtimeWriteStructT();

        // DEBUG: struct
        MidiRealtimeWriteStructT(reaper_plugin_functions::MidiRealtimeWriteStructT^ __0);

        ~MidiRealtimeWriteStructT();

        property double GlobalTime
        {
            double get();
            void set(double);
        }

        property double GlobalItemTime
        {
            double get();
            void set(double);
        }

        property double Srate
        {
            double get();
            void set(double);
        }

        property int Length
        {
            int get();
            void set(int);
        }

        property int Overwritemode
        {
            int get();
            void set(int);
        }

        property reaper_plugin_functions::MIDI_eventlist^ Events
        {
            reaper_plugin_functions::MIDI_eventlist^ get();
            void set(reaper_plugin_functions::MIDI_eventlist^);
        }

        property double ItemPlayrate
        {
            double get();
            void set(double);
        }

        property double Latency
        {
            double get();
            void set(double);
        }

        property unsigned int* OverwriteActives
        {
            unsigned int* get();
            void set(unsigned int*);
        }

        property double DoNotQuantizePastSec
        {
            double get();
            void set(double);
        }

    protected:

        bool __ownsNativeInstance;
    };

    // DEBUG: class PCM_source
    // DEBUG: {
    // DEBUG:   public:
    // DEBUG:     virtual ~PCM_source() { }
    // DEBUG: 
    // DEBUG:     virtual PCM_source *Duplicate()=0;
    // DEBUG: 
    // DEBUG:     virtual bool IsAvailable()=0;
    // DEBUG:     virtual void SetAvailable(bool avail) { } // optional, if called with avail=false, close files/etc, and so on
    // DEBUG:     virtual const char *GetType()=0;
    // DEBUG:     virtual const char *GetFileName() { return NULL; }; // return NULL if no filename (not purely a file)
    // DEBUG:     virtual bool SetFileName(const char *newfn)=0; // return TRUE if supported, this will only be called when offline
    // DEBUG: 
    // DEBUG:     virtual PCM_source *GetSource() { return NULL; }
    // DEBUG:     virtual void SetSource(PCM_source *src) { }
    // DEBUG:     virtual int GetNumChannels()=0; // return number of channels
    // DEBUG:     virtual double GetSampleRate()=0; // returns preferred sample rate. if < 1.0 then it is assumed to be silent (or MIDI)
    // DEBUG:     virtual double GetLength()=0; // length in seconds
    // DEBUG:     virtual double GetLengthBeats() { return -1.0; } // length in beats if supported
    // DEBUG:     virtual int GetBitsPerSample() { return 0; } // returns bits/sample, if available. only used for metadata purposes, since everything returns as doubles anyway
    // DEBUG:     virtual double GetPreferredPosition() { return -1.0; } // not supported returns -1
    // DEBUG: 
    // DEBUG:     virtual int PropertiesWindow(HWND hwndParent)=0;
    // DEBUG: 
    // DEBUG:     virtual void GetSamples(PCM_source_transfer_t *block)=0;
    // DEBUG:     virtual void GetPeakInfo(PCM_source_peaktransfer_t *block)=0;
    // DEBUG: 
    // DEBUG:     virtual void SaveState(ProjectStateContext *ctx)=0;
    // DEBUG:     virtual int LoadState(const char *firstline, ProjectStateContext *ctx)=0; // -1 on error
    // DEBUG: 
    // DEBUG: 
    // DEBUG:     // these are called by the peaks building UI to build peaks for files.
    // DEBUG:     virtual void Peaks_Clear(bool deleteFile)=0;
    // DEBUG:     virtual int PeaksBuild_Begin()=0; // returns nonzero if building is opened, otherwise it may mean building isn't necessary
    // DEBUG:     virtual int PeaksBuild_Run()=0; // returns nonzero if building should continue
    // DEBUG:     virtual void PeaksBuild_Finish()=0; // called when done
    // DEBUG: 
    // DEBUG:     virtual int Extended(int call, void *parm1, void *parm2, void *parm3) { return 0; } // return 0 if unsupported
    // DEBUG: }
    public ref class PCM_source : ICppInstance
    {
    public:

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate bool Func_bool___IntPtr(::System::IntPtr __instance);

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate void Action___IntPtr_bool(::System::IntPtr __instance, bool arg1);

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate bool Func_bool___IntPtr_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string(::System::IntPtr __instance, System::String^ arg1);

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate void Action___IntPtr___IntPtr(::System::IntPtr __instance, reaper_plugin_functions::PCM_source^ arg1);

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate int Func_int___IntPtr(::System::IntPtr __instance);

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate double Func_double___IntPtr(::System::IntPtr __instance);

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate int Func_int___IntPtr___IntPtr(::System::IntPtr __instance, HWND_^ arg1);

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate int Func_int___IntPtr_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string___IntPtr(::System::IntPtr __instance, System::String^ arg1, reaper_plugin_functions::ProjectStateContext^ arg2);

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate int Func_int___IntPtr_int___IntPtr___IntPtr___IntPtr(::System::IntPtr __instance, int arg1, ::System::IntPtr arg2, ::System::IntPtr arg3, ::System::IntPtr arg4);

        property ::PCM_source* NativePtr;
        property System::IntPtr __Instance
        {
            virtual System::IntPtr get();
            virtual void set(System::IntPtr instance);
        }

        PCM_source(::PCM_source* native);
        PCM_source(::PCM_source* native, bool ownNativeInstance);
        static PCM_source^ __CreateInstance(::System::IntPtr native);
        static PCM_source^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
        // DEBUG: PCM_source
        PCM_source();

        // DEBUG: PCM_source
        PCM_source(reaper_plugin_functions::PCM_source^ _0);

        ~PCM_source();

        property reaper_plugin_functions::PCM_source^ Duplicate
        {
            reaper_plugin_functions::PCM_source^ get();
        }

        property bool IsAvailable
        {
            bool get();
        }

        property System::String^ Type
        {
            System::String^ get();
        }

        property System::String^ FileName
        {
            System::String^ get();
            void set(System::String^);
        }

        property reaper_plugin_functions::PCM_source^ Source
        {
            reaper_plugin_functions::PCM_source^ get();
            void set(reaper_plugin_functions::PCM_source^);
        }

        property int NumChannels
        {
            int get();
        }

        property double SampleRate
        {
            double get();
        }

        property double Length
        {
            double get();
        }

        property double LengthBeats
        {
            double get();
        }

        property int BitsPerSample
        {
            int get();
        }

        property double PreferredPosition
        {
            double get();
        }

        property int PeaksBuildBegin
        {
            int get();
        }

        property int PeaksBuildRun
        {
            int get();
        }

        // DEBUG: virtual void SetAvailable(bool avail) { }
        virtual void SetAvailable(bool avail);

        // DEBUG: virtual bool SetFileName(const char *newfn)=0
        virtual bool SetFileName(System::String^ newfn);

        // DEBUG: virtual int PropertiesWindow(HWND hwndParent)=0
        virtual int PropertiesWindow(HWND_^ hwndParent);

        // DEBUG: virtual void GetSamples(PCM_source_transfer_t *block)=0
        virtual void GetSamples(reaper_plugin_functions::PCM_source_transfer_t^ block);

        // DEBUG: virtual void GetPeakInfo(PCM_source_peaktransfer_t *block)=0
        virtual void GetPeakInfo(reaper_plugin_functions::PCM_source_peaktransfer_t^ block);

        // DEBUG: virtual void SaveState(ProjectStateContext *ctx)=0
        virtual void SaveState(reaper_plugin_functions::ProjectStateContext^ ctx);

        // DEBUG: virtual int LoadState(const char *firstline, ProjectStateContext *ctx)=0
        virtual int LoadState(System::String^ firstline, reaper_plugin_functions::ProjectStateContext^ ctx);

        // DEBUG: virtual void Peaks_Clear(bool deleteFile)=0
        virtual void PeaksClear(bool deleteFile);

        // DEBUG: virtual void PeaksBuild_Finish()=0
        virtual void PeaksBuildFinish();

        // DEBUG: virtual int Extended(int call, void *parm1, void *parm2, void *parm3) { return 0; }
        virtual int Extended(int call, ::System::IntPtr parm1, ::System::IntPtr parm2, ::System::IntPtr parm3);

    protected:

        bool __ownsNativeInstance;
    };

    // DEBUG: struct
    // DEBUG: {
    // DEBUG:   int m_id; // ignored for PCM_SINK_EXT_ADDCUE, populated for PCM_SOURCE_EXT_ENUMCUES
    // DEBUG:   double m_time;
    // DEBUG:   double m_endtime;
    // DEBUG:   bool m_isregion;
    // DEBUG:   char *m_name; // can be NULL if unnamed
    // DEBUG:   int m_flags; // &1=DEPRECATED caller must call Extended(PCM_SOURCE_EXT_ENUMCUES, -1, &cue, 0) when finished, &2=time is QN, &0x10000=write cue regardless of sink settings, &4=is chapter
    // DEBUG:   char resvd[124]; // future expansion -- should be 0
    // DEBUG: }
    public ref class REAPER_cue : ICppInstance
    {
    public:

        property ::REAPER_cue* NativePtr;
        property System::IntPtr __Instance
        {
            virtual System::IntPtr get();
            virtual void set(System::IntPtr instance);
        }

        REAPER_cue(::REAPER_cue* native);
        REAPER_cue(::REAPER_cue* native, bool ownNativeInstance);
        static REAPER_cue^ __CreateInstance(::System::IntPtr native);
        static REAPER_cue^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
        // DEBUG: struct
        REAPER_cue();

        // DEBUG: struct
        REAPER_cue(reaper_plugin_functions::REAPER_cue^ __0);

        ~REAPER_cue();

        property int MId
        {
            int get();
            void set(int);
        }

        property double MTime
        {
            double get();
            void set(double);
        }

        property double MEndtime
        {
            double get();
            void set(double);
        }

        property bool MIsregion
        {
            bool get();
            void set(bool);
        }

        property char* MName
        {
            char* get();
            void set(char*);
        }

        property int MFlags
        {
            int get();
            void set(int);
        }

        property cli::array<char>^ Resvd
        {
            cli::array<char>^ get();
            void set(cli::array<char>^);
        }

    protected:

        bool __ownsNativeInstance;
    };

    // DEBUG: struct
    // DEBUG: {
    // DEBUG:   PCM_source* m_sliceSrc;
    // DEBUG:   double m_beatSnapOffset;
    // DEBUG:   int flag; // &1=only return beatsnapoffset, not slicesrc
    // DEBUG:   char resvd[124];  // future expansion -- should be 0
    // DEBUG: }
    public ref class REAPER_slice : ICppInstance
    {
    public:

        property ::REAPER_slice* NativePtr;
        property System::IntPtr __Instance
        {
            virtual System::IntPtr get();
            virtual void set(System::IntPtr instance);
        }

        REAPER_slice(::REAPER_slice* native);
        REAPER_slice(::REAPER_slice* native, bool ownNativeInstance);
        static REAPER_slice^ __CreateInstance(::System::IntPtr native);
        static REAPER_slice^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
        // DEBUG: struct
        REAPER_slice();

        // DEBUG: struct
        REAPER_slice(reaper_plugin_functions::REAPER_slice^ __0);

        ~REAPER_slice();

        property reaper_plugin_functions::PCM_source^ MSliceSrc
        {
            reaper_plugin_functions::PCM_source^ get();
            void set(reaper_plugin_functions::PCM_source^);
        }

        property double MBeatSnapOffset
        {
            double get();
            void set(double);
        }

        property int Flag
        {
            int get();
            void set(int);
        }

        property cli::array<char>^ Resvd
        {
            cli::array<char>^ get();
            void set(cli::array<char>^);
        }

    protected:

        bool __ownsNativeInstance;
    };

    // DEBUG: struct
    // DEBUG: {
    // DEBUG:   double draw_start_time; // project time at pixel start of draw
    // DEBUG:   int draw_start_y;       // if y-scroll is partway into the item, positive pixel value
    // DEBUG:   double pixels_per_second;
    // DEBUG: 
    // DEBUG:   int width, height; // width and height of view of the item. if doing a partial update this may be larger than the bitmap passed in
    // DEBUG:   int mouse_x, mouse_y; // valid only on mouse/key/setcursor/etc messages
    // DEBUG: 
    // DEBUG:   void *extraParms[8];
    // DEBUG:   // WM_KEYDOWN handlers can use MSG *msg = (MSG *)extraParms[0]
    // DEBUG:   // WM_SETCURSOR handlers should set *extraParms[0] = hcursor
    // DEBUG: }
    public ref class REAPER_inline_positioninfo : ICppInstance
    {
    public:

        property ::REAPER_inline_positioninfo* NativePtr;
        property System::IntPtr __Instance
        {
            virtual System::IntPtr get();
            virtual void set(System::IntPtr instance);
        }

        REAPER_inline_positioninfo(::REAPER_inline_positioninfo* native);
        REAPER_inline_positioninfo(::REAPER_inline_positioninfo* native, bool ownNativeInstance);
        static REAPER_inline_positioninfo^ __CreateInstance(::System::IntPtr native);
        static REAPER_inline_positioninfo^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
        // DEBUG: struct
        REAPER_inline_positioninfo();

        // DEBUG: struct
        REAPER_inline_positioninfo(reaper_plugin_functions::REAPER_inline_positioninfo^ __0);

        ~REAPER_inline_positioninfo();

        property double DrawStartTime
        {
            double get();
            void set(double);
        }

        property int DrawStartY
        {
            int get();
            void set(int);
        }

        property double PixelsPerSecond
        {
            double get();
            void set(double);
        }

        property int Width
        {
            int get();
            void set(int);
        }

        property int Height
        {
            int get();
            void set(int);
        }

        property int MouseX
        {
            int get();
            void set(int);
        }

        property int MouseY
        {
            int get();
            void set(int);
        }

        property cli::array<::System::IntPtr>^ ExtraParms
        {
            cli::array<::System::IntPtr>^ get();
            void set(cli::array<::System::IntPtr>^);
        }

    protected:

        bool __ownsNativeInstance;
    };

    // DEBUG: struct {
    // DEBUG:   PCM_source *(*CreateFromType)(const char *type, int priority); // priority is 0-7, 0 is highest
    // DEBUG:   PCM_source *(*CreateFromFile)(const char *filename, int priority); // if priority is 5-7, and the file isn't found, open it in an offline state anyway, thanks
    // DEBUG: 
    // DEBUG:   // this is used for UI only, not so muc
    // DEBUG:   const char *(*EnumFileExtensions)(int i, const char **descptr); // call increasing i until returns a string, if descptr's output is NULL, use last description
    // DEBUG: }
    public ref class PcmsrcRegisterT : ICppInstance
    {
    public:

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate reaper_plugin_functions::PCM_source^ Func___IntPtr_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string_int(System::String^ type, int priority);

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate System::String^ Func___IntPtr_int_sbytePtrPtr(int i, System::String^* descptr);

        property ::pcmsrc_register_t* NativePtr;
        property System::IntPtr __Instance
        {
            virtual System::IntPtr get();
            virtual void set(System::IntPtr instance);
        }

        PcmsrcRegisterT(::pcmsrc_register_t* native);
        PcmsrcRegisterT(::pcmsrc_register_t* native, bool ownNativeInstance);
        static PcmsrcRegisterT^ __CreateInstance(::System::IntPtr native);
        static PcmsrcRegisterT^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
        // DEBUG: struct
        PcmsrcRegisterT();

        // DEBUG: struct
        PcmsrcRegisterT(reaper_plugin_functions::PcmsrcRegisterT^ __0);

        ~PcmsrcRegisterT();

        property reaper_plugin_functions::PcmsrcRegisterT::Func___IntPtr_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string_int^ CreateFromType
        {
            reaper_plugin_functions::PcmsrcRegisterT::Func___IntPtr_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string_int^ get();
            void set(reaper_plugin_functions::PcmsrcRegisterT::Func___IntPtr_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string_int^);
        }

        property reaper_plugin_functions::PcmsrcRegisterT::Func___IntPtr_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string_int^ CreateFromFile
        {
            reaper_plugin_functions::PcmsrcRegisterT::Func___IntPtr_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string_int^ get();
            void set(reaper_plugin_functions::PcmsrcRegisterT::Func___IntPtr_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string_int^);
        }

        property reaper_plugin_functions::PcmsrcRegisterT::Func___IntPtr_int_sbytePtrPtr^ EnumFileExtensions
        {
            reaper_plugin_functions::PcmsrcRegisterT::Func___IntPtr_int_sbytePtrPtr^ get();
            void set(reaper_plugin_functions::PcmsrcRegisterT::Func___IntPtr_int_sbytePtrPtr^);
        }

    protected:

        bool __ownsNativeInstance;
    };

    // DEBUG: class ISimpleMediaDecoder
    // DEBUG: {
    // DEBUG: public:
    // DEBUG:   virtual ~ISimpleMediaDecoder() { }
    // DEBUG: 
    // DEBUG:   virtual ISimpleMediaDecoder *Duplicate()=0;
    // DEBUG: 
    // DEBUG:   // filename can be NULL to use "last filename"
    // DEBUG:   // diskread* are suggested values to pass to WDL_FileRead if you use it, otherwise can ignore
    // DEBUG:   virtual void Open(const char *filename, int diskreadmode, int diskreadbs, int diskreadnb)=0;
    // DEBUG: 
    // DEBUG:   // if fullClose=0, close disk resources, but can leave decoders etc initialized (and subsequently check the file date on re-open)
    // DEBUG:   virtual void Close(bool fullClose)=0; 
    // DEBUG: 
    // DEBUG:   virtual const char *GetFileName()=0;
    // DEBUG:   virtual const char *GetType()=0;
    // DEBUG: 
    // DEBUG:   // an info string suitable for a dialog, and a title for that dialog
    // DEBUG:   virtual void GetInfoString(char *buf, int buflen, char *title, int titlelen)=0; 
    // DEBUG: 
    // DEBUG:   virtual bool IsOpen()=0;
    // DEBUG:   virtual int GetNumChannels()=0;
    // DEBUG: 
    // DEBUG:   virtual int GetBitsPerSample()=0;
    // DEBUG:   virtual double GetSampleRate()=0;
    // DEBUG: 
    // DEBUG: 
    // DEBUG:   // positions in sample frames
    // DEBUG:   virtual INT64 GetLength()=0;
    // DEBUG:   virtual INT64 GetPosition()=0;
    // DEBUG:   virtual void SetPosition(INT64 pos)=0;
    // DEBUG: 
    // DEBUG:   // returns sample-frames read. buf will be at least length*GetNumChannels() ReaSamples long.
    // DEBUG:   virtual int ReadSamples(ReaSample *buf, int length)=0; 
    // DEBUG: 
    // DEBUG: 
    // DEBUG:   // these extended messages may include PCM_source messages
    // DEBUG:   virtual int Extended(int call, void *parm1, void *parm2, void *parm3) { return 0; } // return 0 if unsupported
    // DEBUG: }
    public ref class ISimpleMediaDecoder : ICppInstance
    {
    public:

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate void Action___IntPtr_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string_int_int_int(::System::IntPtr __instance, System::String^ arg1, int arg2, int arg3, int arg4);

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate void Action___IntPtr_sbytePtr_int_sbytePtr_int(::System::IntPtr __instance, char* arg1, int arg2, char* arg3, int arg4);

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate void Action___IntPtr_long(::System::IntPtr __instance, long long arg1);

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate int Func_int___IntPtr_doublePtr_int(::System::IntPtr __instance, [System::Runtime::InteropServices::In, System::Runtime::InteropServices::Out] double% arg1, int arg2);

        property ::ISimpleMediaDecoder* NativePtr;
        property System::IntPtr __Instance
        {
            virtual System::IntPtr get();
            virtual void set(System::IntPtr instance);
        }

        ISimpleMediaDecoder(::ISimpleMediaDecoder* native);
        ISimpleMediaDecoder(::ISimpleMediaDecoder* native, bool ownNativeInstance);
        static ISimpleMediaDecoder^ __CreateInstance(::System::IntPtr native);
        static ISimpleMediaDecoder^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
        // DEBUG: ISimpleMediaDecoder
        ISimpleMediaDecoder();

        // DEBUG: ISimpleMediaDecoder
        ISimpleMediaDecoder(reaper_plugin_functions::ISimpleMediaDecoder^ _0);

        ~ISimpleMediaDecoder();

        property reaper_plugin_functions::ISimpleMediaDecoder^ Duplicate
        {
            reaper_plugin_functions::ISimpleMediaDecoder^ get();
        }

        property System::String^ FileName
        {
            System::String^ get();
        }

        property System::String^ Type
        {
            System::String^ get();
        }

        property bool IsOpen
        {
            bool get();
        }

        property int NumChannels
        {
            int get();
        }

        property int BitsPerSample
        {
            int get();
        }

        property double SampleRate
        {
            double get();
        }

        property long long Length
        {
            long long get();
        }

        property long long Position
        {
            long long get();
            void set(long long);
        }

        // DEBUG: virtual void Open(const char *filename, int diskreadmode, int diskreadbs, int diskreadnb)=0
        virtual void Open(System::String^ filename, int diskreadmode, int diskreadbs, int diskreadnb);

        // DEBUG: virtual void Close(bool fullClose)=0
        virtual void Close(bool fullClose);

        // DEBUG: virtual void GetInfoString(char *buf, int buflen, char *title, int titlelen)=0
        virtual void GetInfoString(char* buf, int buflen, char* title, int titlelen);

        // DEBUG: virtual int ReadSamples(ReaSample *buf, int length)=0
        virtual int ReadSamples([System::Runtime::InteropServices::In, System::Runtime::InteropServices::Out] double% buf, int length);

        // DEBUG: virtual int Extended(int call, void *parm1, void *parm2, void *parm3) { return 0; }
        virtual int Extended(int call, ::System::IntPtr parm1, ::System::IntPtr parm2, ::System::IntPtr parm3);

    protected:

        bool __ownsNativeInstance;
    };

    /// <summary>
    /// <para>*************************************************************************************</para>
    /// <para>*** PCM sink API</para>
    /// <para>*************************************************************************************</para>
    /// </summary>
    // DEBUG: struct
    // DEBUG: {
    // DEBUG:   bool doquant;
    // DEBUG:   char movemode; // 0=default(l/r), -1=left only, 1=right only
    // DEBUG:   char sizemode; // 0=preserve length, 1=quantize end
    // DEBUG:   char quantstrength; // 1-100
    // DEBUG:   double quantamt; // quantize to (in qn)
    // DEBUG:   char swingamt; // 1-100
    // DEBUG:   char range_min; // 0-100
    // DEBUG:   char range_max; 
    // DEBUG: }
    public ref class MidiQuantizeModeT : ICppInstance
    {
    public:

        property ::midi_quantize_mode_t* NativePtr;
        property System::IntPtr __Instance
        {
            virtual System::IntPtr get();
            virtual void set(System::IntPtr instance);
        }

        MidiQuantizeModeT(::midi_quantize_mode_t* native);
        MidiQuantizeModeT(::midi_quantize_mode_t* native, bool ownNativeInstance);
        static MidiQuantizeModeT^ __CreateInstance(::System::IntPtr native);
        static MidiQuantizeModeT^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
        // DEBUG: struct
        MidiQuantizeModeT();

        // DEBUG: struct
        MidiQuantizeModeT(reaper_plugin_functions::MidiQuantizeModeT^ __0);

        ~MidiQuantizeModeT();

        property bool Doquant
        {
            bool get();
            void set(bool);
        }

        property char Movemode
        {
            char get();
            void set(char);
        }

        property char Sizemode
        {
            char get();
            void set(char);
        }

        property char Quantstrength
        {
            char get();
            void set(char);
        }

        property double Quantamt
        {
            double get();
            void set(double);
        }

        property char Swingamt
        {
            char get();
            void set(char);
        }

        property char RangeMin
        {
            char get();
            void set(char);
        }

        property char RangeMax
        {
            char get();
            void set(char);
        }

    protected:

        bool __ownsNativeInstance;
    };

    // DEBUG: class PCM_sink
    // DEBUG: {
    // DEBUG:   public:
    // DEBUG:     PCM_sink() { m_st=0.0; }
    // DEBUG:     virtual ~PCM_sink() { }
    // DEBUG: 
    // DEBUG:     virtual void GetOutputInfoString(char *buf, int buflen)=0;
    // DEBUG:     virtual double GetStartTime() { return m_st; }
    // DEBUG:     virtual void SetStartTime(double st) { m_st=st; }
    // DEBUG:     virtual const char *GetFileName()=0; // get filename, if applicable (otherwise "")
    // DEBUG:     virtual int GetNumChannels()=0; // return number of channels
    // DEBUG:     virtual double GetLength()=0; // length in seconds, so far
    // DEBUG:     virtual INT64 GetFileSize()=0;
    // DEBUG: 
    // DEBUG:     virtual void WriteMIDI(MIDI_eventlist *events, int len, double samplerate)=0;
    // DEBUG:     virtual void WriteDoubles(ReaSample **samples, int len, int nch, int offset, int spacing)=0;
    // DEBUG:     virtual bool WantMIDI() { return 0; }
    // DEBUG: 
    // DEBUG:     virtual int GetLastSecondPeaks(int sz, ReaSample *buf) { return 0; }
    // DEBUG:     virtual void GetPeakInfo(PCM_source_peaktransfer_t *block) { } // allow getting of peaks thus far
    // DEBUG: 
    // DEBUG:     virtual int Extended(int call, void *parm1, void *parm2, void *parm3) { return 0; } // return 0 if unsupported
    // DEBUG: 
    // DEBUG:   private:
    // DEBUG:     double m_st;
    // DEBUG: }
    public ref class PCM_sink : ICppInstance
    {
    public:

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate void Action___IntPtr_sbytePtr_int(::System::IntPtr __instance, char* arg1, int arg2);

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate void Action___IntPtr_double(::System::IntPtr __instance, double arg1);

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate long long Func_long___IntPtr(::System::IntPtr __instance);

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate void Action___IntPtr___IntPtr_int_double(::System::IntPtr __instance, reaper_plugin_functions::MIDI_eventlist^ arg1, int arg2, double arg3);

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate void Action___IntPtr_doublePtrPtr_int_int_int_int(::System::IntPtr __instance, double** arg1, int arg2, int arg3, int arg4, int arg5);

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate int Func_int___IntPtr_int_doublePtr(::System::IntPtr __instance, int arg1, [System::Runtime::InteropServices::In, System::Runtime::InteropServices::Out] double% arg2);

        property ::PCM_sink* NativePtr;
        property System::IntPtr __Instance
        {
            virtual System::IntPtr get();
            virtual void set(System::IntPtr instance);
        }

        PCM_sink(::PCM_sink* native);
        PCM_sink(::PCM_sink* native, bool ownNativeInstance);
        static PCM_sink^ __CreateInstance(::System::IntPtr native);
        static PCM_sink^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
        // DEBUG: PCM_sink() { m_st=0.0; }
        PCM_sink();

        // DEBUG: PCM_sink
        PCM_sink(reaper_plugin_functions::PCM_sink^ _0);

        ~PCM_sink();

        property double StartTime
        {
            double get();
            void set(double);
        }

        property System::String^ FileName
        {
            System::String^ get();
        }

        property int NumChannels
        {
            int get();
        }

        property double Length
        {
            double get();
        }

        property long long FileSize
        {
            long long get();
        }

        property bool WantMIDI
        {
            bool get();
        }

        // DEBUG: virtual void GetOutputInfoString(char *buf, int buflen)=0
        virtual void GetOutputInfoString(char* buf, int buflen);

        // DEBUG: virtual void WriteMIDI(MIDI_eventlist *events, int len, double samplerate)=0
        virtual void WriteMIDI(reaper_plugin_functions::MIDI_eventlist^ events, int len, double samplerate);

        // DEBUG: virtual void WriteDoubles(ReaSample **samples, int len, int nch, int offset, int spacing)=0
        virtual void WriteDoubles(double** samples, int len, int nch, int offset, int spacing);

        // DEBUG: virtual int GetLastSecondPeaks(int sz, ReaSample *buf) { return 0; }
        virtual int GetLastSecondPeaks(int sz, [System::Runtime::InteropServices::In, System::Runtime::InteropServices::Out] double% buf);

        // DEBUG: virtual void GetPeakInfo(PCM_source_peaktransfer_t *block) { }
        virtual void GetPeakInfo(reaper_plugin_functions::PCM_source_peaktransfer_t^ block);

        // DEBUG: virtual int Extended(int call, void *parm1, void *parm2, void *parm3) { return 0; }
        virtual int Extended(int call, ::System::IntPtr parm1, ::System::IntPtr parm2, ::System::IntPtr parm3);

    protected:

        bool __ownsNativeInstance;
    };

    // DEBUG: struct  // register using "pcmsink"
    // DEBUG: {
    // DEBUG:   unsigned int (*GetFmt)(const char **desc);
    // DEBUG: 
    // DEBUG:   const char *(*GetExtension)(const void *cfg, int cfg_l);
    // DEBUG:   HWND (*ShowConfig)(const void *cfg, int cfg_l, HWND parent);
    // DEBUG:   PCM_sink *(*CreateSink)(const char *filename, void *cfg, int cfg_l, int nch, int srate, bool buildpeaks);
    // DEBUG: 
    // DEBUG: }
    public ref class PcmsinkRegisterT : ICppInstance
    {
    public:

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate unsigned int Func_uint_sbytePtrPtr(System::String^* desc);

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate System::String^ Func___IntPtr___IntPtr_int(::System::IntPtr cfg, int cfg_l);

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate HWND_^ Func___IntPtr___IntPtr_int___IntPtr(::System::IntPtr cfg, int cfg_l, HWND_^ parent);

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate reaper_plugin_functions::PCM_sink^ Func___IntPtr_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string___IntPtr_int_int_int_bool(System::String^ filename, ::System::IntPtr cfg, int cfg_l, int nch, int srate, bool buildpeaks);

        property ::pcmsink_register_t* NativePtr;
        property System::IntPtr __Instance
        {
            virtual System::IntPtr get();
            virtual void set(System::IntPtr instance);
        }

        PcmsinkRegisterT(::pcmsink_register_t* native);
        PcmsinkRegisterT(::pcmsink_register_t* native, bool ownNativeInstance);
        static PcmsinkRegisterT^ __CreateInstance(::System::IntPtr native);
        static PcmsinkRegisterT^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
        // DEBUG: struct
        PcmsinkRegisterT();

        // DEBUG: struct
        PcmsinkRegisterT(reaper_plugin_functions::PcmsinkRegisterT^ __0);

        ~PcmsinkRegisterT();

        property reaper_plugin_functions::PcmsinkRegisterT::Func_uint_sbytePtrPtr^ GetFmt
        {
            reaper_plugin_functions::PcmsinkRegisterT::Func_uint_sbytePtrPtr^ get();
            void set(reaper_plugin_functions::PcmsinkRegisterT::Func_uint_sbytePtrPtr^);
        }

        property reaper_plugin_functions::PcmsinkRegisterT::Func___IntPtr___IntPtr_int^ GetExtension
        {
            reaper_plugin_functions::PcmsinkRegisterT::Func___IntPtr___IntPtr_int^ get();
            void set(reaper_plugin_functions::PcmsinkRegisterT::Func___IntPtr___IntPtr_int^);
        }

        property reaper_plugin_functions::PcmsinkRegisterT::Func___IntPtr___IntPtr_int___IntPtr^ ShowConfig
        {
            reaper_plugin_functions::PcmsinkRegisterT::Func___IntPtr___IntPtr_int___IntPtr^ get();
            void set(reaper_plugin_functions::PcmsinkRegisterT::Func___IntPtr___IntPtr_int___IntPtr^);
        }

        property reaper_plugin_functions::PcmsinkRegisterT::Func___IntPtr_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string___IntPtr_int_int_int_bool^ CreateSink
        {
            reaper_plugin_functions::PcmsinkRegisterT::Func___IntPtr_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string___IntPtr_int_int_int_bool^ get();
            void set(reaper_plugin_functions::PcmsinkRegisterT::Func___IntPtr_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string___IntPtr_int_int_int_bool^);
        }

    protected:

        bool __ownsNativeInstance;
    };

    // DEBUG: struct  // register using "pcmsink_ext"
    // DEBUG: {
    // DEBUG:   pcmsink_register_t sink; 
    // DEBUG: 
    // DEBUG:   // for extended calls that refer to the generic type of sink, rather than a specific instance of a sink
    // DEBUG:   int (*Extended)(int call, void* parm1, void* parm2, void* parm3); 
    // DEBUG: 
    // DEBUG: 
    // DEBUG:   char expand[256];
    // DEBUG: }
    public ref class PcmsinkRegisterExtT : ICppInstance
    {
    public:

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate int Func_int_int___IntPtr___IntPtr___IntPtr(int call, ::System::IntPtr parm1, ::System::IntPtr parm2, ::System::IntPtr parm3);

        property ::pcmsink_register_ext_t* NativePtr;
        property System::IntPtr __Instance
        {
            virtual System::IntPtr get();
            virtual void set(System::IntPtr instance);
        }

        PcmsinkRegisterExtT(::pcmsink_register_ext_t* native);
        PcmsinkRegisterExtT(::pcmsink_register_ext_t* native, bool ownNativeInstance);
        static PcmsinkRegisterExtT^ __CreateInstance(::System::IntPtr native);
        static PcmsinkRegisterExtT^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
        // DEBUG: struct
        PcmsinkRegisterExtT();

        // DEBUG: struct
        PcmsinkRegisterExtT(reaper_plugin_functions::PcmsinkRegisterExtT^ __0);

        ~PcmsinkRegisterExtT();

        property reaper_plugin_functions::PcmsinkRegisterT^ Sink
        {
            reaper_plugin_functions::PcmsinkRegisterT^ get();
            void set(reaper_plugin_functions::PcmsinkRegisterT^);
        }

        property reaper_plugin_functions::PcmsinkRegisterExtT::Func_int_int___IntPtr___IntPtr___IntPtr^ Extended
        {
            reaper_plugin_functions::PcmsinkRegisterExtT::Func_int_int___IntPtr___IntPtr___IntPtr^ get();
            void set(reaper_plugin_functions::PcmsinkRegisterExtT::Func_int_int___IntPtr___IntPtr___IntPtr^);
        }

        property cli::array<char>^ Expand
        {
            cli::array<char>^ get();
            void set(cli::array<char>^);
        }

    protected:

        bool __ownsNativeInstance;
    };

    /// <summary>
    /// <para>*************************************************************************************</para>
    /// <para>*** Resampler API (plug-ins can use this for SRC)</para>
    /// <para>*</para>
    /// <para>*</para>
    /// <para>* See API functions Resampler_Create() and Resample_EnumModes()</para>
    /// <para>*************************************************************************************</para>
    /// </summary>
    // DEBUG: class REAPER_Resample_Interface
    // DEBUG: {
    // DEBUG: public:
    // DEBUG:   virtual ~REAPER_Resample_Interface(){}
    // DEBUG:   virtual void SetRates(double rate_in, double rate_out)=0;
    // DEBUG:   virtual void Reset()=0;
    // DEBUG: 
    // DEBUG:   virtual double GetCurrentLatency()=0; // latency in seconds buffered -- do not call between resampleprepare and resampleout, undefined if you do...
    // DEBUG:   virtual int ResamplePrepare(int out_samples, int nch, ReaSample **inbuffer)=0; // sample ratio
    // DEBUG:   virtual int ResampleOut(ReaSample *out, int nsamples_in, int nsamples_out, int nch)=0; // returns output samples
    // DEBUG: 
    // DEBUG:   virtual int Extended(int call, void *parm1, void *parm2, void *parm3) { return 0; } // return 0 if unsupported
    // DEBUG: }
    public ref class REAPER_ResampleInterface : ICppInstance
    {
    public:

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate void Action___IntPtr_double_double(::System::IntPtr __instance, double arg1, double arg2);

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate int Func_int___IntPtr_int_int_doublePtrPtr(::System::IntPtr __instance, int arg1, int arg2, double** arg3);

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate int Func_int___IntPtr_doublePtr_int_int_int(::System::IntPtr __instance, [System::Runtime::InteropServices::In, System::Runtime::InteropServices::Out] double% arg1, int arg2, int arg3, int arg4);

        property ::REAPER_Resample_Interface* NativePtr;
        property System::IntPtr __Instance
        {
            virtual System::IntPtr get();
            virtual void set(System::IntPtr instance);
        }

        REAPER_ResampleInterface(::REAPER_Resample_Interface* native);
        REAPER_ResampleInterface(::REAPER_Resample_Interface* native, bool ownNativeInstance);
        static REAPER_ResampleInterface^ __CreateInstance(::System::IntPtr native);
        static REAPER_ResampleInterface^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
        // DEBUG: REAPER_Resample_Interface
        REAPER_ResampleInterface();

        // DEBUG: REAPER_Resample_Interface
        REAPER_ResampleInterface(reaper_plugin_functions::REAPER_ResampleInterface^ _0);

        ~REAPER_ResampleInterface();

        property double CurrentLatency
        {
            double get();
        }

        // DEBUG: virtual void SetRates(double rate_in, double rate_out)=0
        virtual void SetRates(double rate_in, double rate_out);

        // DEBUG: virtual void Reset()=0
        virtual void Reset();

        // DEBUG: virtual int ResamplePrepare(int out_samples, int nch, ReaSample **inbuffer)=0
        virtual int ResamplePrepare(int out_samples, int nch, double** inbuffer);

        // DEBUG: virtual int ResampleOut(ReaSample *out, int nsamples_in, int nsamples_out, int nch)=0
        virtual int ResampleOut([System::Runtime::InteropServices::In, System::Runtime::InteropServices::Out] double% out, int nsamples_in, int nsamples_out, int nch);

        // DEBUG: virtual int Extended(int call, void *parm1, void *parm2, void *parm3) { return 0; }
        virtual int Extended(int call, ::System::IntPtr parm1, ::System::IntPtr parm2, ::System::IntPtr parm3);

    protected:

        bool __ownsNativeInstance;
    };

    // DEBUG: class IReaperPitchShift
    // DEBUG: {
    // DEBUG:   public:
    // DEBUG:     virtual ~IReaperPitchShift() { };
    // DEBUG:     virtual void set_srate(double srate)=0;
    // DEBUG:     virtual void set_nch(int nch)=0;
    // DEBUG:     virtual void set_shift(double shift)=0;
    // DEBUG:     virtual void set_formant_shift(double shift)=0; // shift can be <0 for "only shift when in formant preserve mode", so that you can use it for effective rate changes etc in that mode
    // DEBUG:     virtual void set_tempo(double tempo)=0;
    // DEBUG: 
    // DEBUG:     virtual void Reset()=0;  // reset all buffers/latency
    // DEBUG:     virtual ReaSample *GetBuffer(int size)=0;
    // DEBUG:     virtual void BufferDone(int input_filled)=0;
    // DEBUG: 
    // DEBUG:     virtual void FlushSamples()=0; // make sure all output is available
    // DEBUG: 
    // DEBUG:     virtual bool IsReset()=0;
    // DEBUG: 
    // DEBUG:     virtual int GetSamples(int requested_output, ReaSample *buffer)=0; // returns number of samplepairs returned
    // DEBUG: 
    // DEBUG:     virtual void SetQualityParameter(int parm)=0; // set to: (mode<<16)+(submode), or -1 for "project default" (default)
    // DEBUG:     virtual int Extended(int call, void *parm1, void *parm2, void *parm3) { return 0; } // return 0 if unsupported
    // DEBUG: }
    public ref class IReaperPitchShift : ICppInstance
    {
    public:

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate double* Func_doublePtr___IntPtr_int(::System::IntPtr __instance, int arg1);

        property ::IReaperPitchShift* NativePtr;
        property System::IntPtr __Instance
        {
            virtual System::IntPtr get();
            virtual void set(System::IntPtr instance);
        }

        IReaperPitchShift(::IReaperPitchShift* native);
        IReaperPitchShift(::IReaperPitchShift* native, bool ownNativeInstance);
        static IReaperPitchShift^ __CreateInstance(::System::IntPtr native);
        static IReaperPitchShift^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
        // DEBUG: IReaperPitchShift
        IReaperPitchShift();

        // DEBUG: IReaperPitchShift
        IReaperPitchShift(reaper_plugin_functions::IReaperPitchShift^ _0);

        ~IReaperPitchShift();

        property bool IsReset
        {
            bool get();
        }

        // DEBUG: virtual void set_srate(double srate)=0
        virtual void SetSrate(double srate);

        // DEBUG: virtual void set_nch(int nch)=0
        virtual void SetNch(int nch);

        // DEBUG: virtual void set_shift(double shift)=0
        virtual void SetShift(double shift);

        // DEBUG: virtual void set_formant_shift(double shift)=0
        virtual void SetFormantShift(double shift);

        // DEBUG: virtual void set_tempo(double tempo)=0
        virtual void SetTempo(double tempo);

        // DEBUG: virtual void Reset()=0
        virtual void Reset();

        // DEBUG: virtual ReaSample *GetBuffer(int size)=0
        virtual double* GetBuffer(int size);

        // DEBUG: virtual void BufferDone(int input_filled)=0
        virtual void BufferDone(int input_filled);

        // DEBUG: virtual void FlushSamples()=0
        virtual void FlushSamples();

        // DEBUG: virtual int GetSamples(int requested_output, ReaSample *buffer)=0
        virtual int GetSamples(int requested_output, [System::Runtime::InteropServices::In, System::Runtime::InteropServices::Out] double% buffer);

        // DEBUG: virtual void SetQualityParameter(int parm)=0
        virtual void SetQualityParameter(int parm);

        // DEBUG: virtual int Extended(int call, void *parm1, void *parm2, void *parm3) { return 0; }
        virtual int Extended(int call, ::System::IntPtr parm1, ::System::IntPtr parm2, ::System::IntPtr parm3);

    protected:

        bool __ownsNativeInstance;
    };

    /// <summary>
    /// <para>*************************************************************************************</para>
    /// <para>*** Peak getting/building API</para>
    /// <para>*</para>
    /// <para>* These are really only needed if you implement a PCM_source or PCM_sink.</para>
    /// <para>*</para>
    /// <para>* See functions PeakGet_Create(), PeakBuild_Create(), GetPeakFileName(), ClearPeakCache()</para>
    /// <para>*</para>
    /// <para>*************************************************************************************</para>
    /// </summary>
    // DEBUG: class REAPER_PeakGet_Interface
    // DEBUG: {
    // DEBUG: public:
    // DEBUG:   virtual ~REAPER_PeakGet_Interface() { }
    // DEBUG: 
    // DEBUG:   virtual double GetMaxPeakRes()=0;
    // DEBUG:   virtual void GetPeakInfo(PCM_source_peaktransfer_t *block)=0;
    // DEBUG: 
    // DEBUG:   virtual int Extended(int call, void *parm1, void *parm2, void *parm3) { return 0; } // return 0 if unsupported
    // DEBUG: }
    public ref class REAPER_PeakGetInterface : ICppInstance
    {
    public:

        property ::REAPER_PeakGet_Interface* NativePtr;
        property System::IntPtr __Instance
        {
            virtual System::IntPtr get();
            virtual void set(System::IntPtr instance);
        }

        REAPER_PeakGetInterface(::REAPER_PeakGet_Interface* native);
        REAPER_PeakGetInterface(::REAPER_PeakGet_Interface* native, bool ownNativeInstance);
        static REAPER_PeakGetInterface^ __CreateInstance(::System::IntPtr native);
        static REAPER_PeakGetInterface^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
        // DEBUG: REAPER_PeakGet_Interface
        REAPER_PeakGetInterface();

        // DEBUG: REAPER_PeakGet_Interface
        REAPER_PeakGetInterface(reaper_plugin_functions::REAPER_PeakGetInterface^ _0);

        ~REAPER_PeakGetInterface();

        property double MaxPeakRes
        {
            double get();
        }

        // DEBUG: virtual void GetPeakInfo(PCM_source_peaktransfer_t *block)=0
        virtual void GetPeakInfo(reaper_plugin_functions::PCM_source_peaktransfer_t^ block);

        // DEBUG: virtual int Extended(int call, void *parm1, void *parm2, void *parm3) { return 0; }
        virtual int Extended(int call, ::System::IntPtr parm1, ::System::IntPtr parm2, ::System::IntPtr parm3);

    protected:

        bool __ownsNativeInstance;
    };

    // DEBUG: class REAPER_PeakBuild_Interface
    // DEBUG: {
    // DEBUG: public:
    // DEBUG:   virtual ~REAPER_PeakBuild_Interface() { }
    // DEBUG: 
    // DEBUG:   virtual void ProcessSamples(ReaSample **samples, int len, int nch, int offs, int spread)=0; // in case a sink wants to build its own peaks (make sure it was created with src=NULL)
    // DEBUG:   virtual int Run()=0; // or let it do it automatically (created with source!=NULL)
    // DEBUG: 
    // DEBUG:   virtual int GetLastSecondPeaks(int sz, ReaSample *buf)=0; // returns number of peaks in the last second, sz is maxsize
    // DEBUG:   virtual void GetPeakInfo(PCM_source_peaktransfer_t *block)=0; // allow getting of peaks thus far (won't hit the highest resolution mipmap, just the 10/sec one or so)
    // DEBUG: 
    // DEBUG:   virtual int Extended(int call, void *parm1, void *parm2, void *parm3) { return 0; } // return 0 if unsupported
    // DEBUG: }
    public ref class REAPER_PeakBuildInterface : ICppInstance
    {
    public:

        property ::REAPER_PeakBuild_Interface* NativePtr;
        property System::IntPtr __Instance
        {
            virtual System::IntPtr get();
            virtual void set(System::IntPtr instance);
        }

        REAPER_PeakBuildInterface(::REAPER_PeakBuild_Interface* native);
        REAPER_PeakBuildInterface(::REAPER_PeakBuild_Interface* native, bool ownNativeInstance);
        static REAPER_PeakBuildInterface^ __CreateInstance(::System::IntPtr native);
        static REAPER_PeakBuildInterface^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
        // DEBUG: REAPER_PeakBuild_Interface
        REAPER_PeakBuildInterface();

        // DEBUG: REAPER_PeakBuild_Interface
        REAPER_PeakBuildInterface(reaper_plugin_functions::REAPER_PeakBuildInterface^ _0);

        ~REAPER_PeakBuildInterface();

        // DEBUG: virtual void ProcessSamples(ReaSample **samples, int len, int nch, int offs, int spread)=0
        virtual void ProcessSamples(double** samples, int len, int nch, int offs, int spread);

        // DEBUG: virtual int Run()=0
        virtual int Run();

        // DEBUG: virtual int GetLastSecondPeaks(int sz, ReaSample *buf)=0
        virtual int GetLastSecondPeaks(int sz, [System::Runtime::InteropServices::In, System::Runtime::InteropServices::Out] double% buf);

        // DEBUG: virtual void GetPeakInfo(PCM_source_peaktransfer_t *block)=0
        virtual void GetPeakInfo(reaper_plugin_functions::PCM_source_peaktransfer_t^ block);

        // DEBUG: virtual int Extended(int call, void *parm1, void *parm2, void *parm3) { return 0; }
        virtual int Extended(int call, ::System::IntPtr parm1, ::System::IntPtr parm2, ::System::IntPtr parm3);

    protected:

        bool __ownsNativeInstance;
    };

    // DEBUG: struct accelerator_register_t
    // DEBUG: {
    // DEBUG:   // translateAccel returns:
    // DEBUG:   // 0 if not our window, 
    // DEBUG:   // 1 to eat the keystroke, 
    // DEBUG:   // -1 to pass it on to the window, 
    // DEBUG:   // -10 (macOS only) to process event raw
    // DEBUG:   // -20 (Windows only) to passed to the window, even if it is WM_SYSKEY*/VK_MENU which would otherwise be dropped
    // DEBUG:   // -666 to force it to the main window's accel table (with the exception of ESC)
    // DEBUG:   // -667 to force it to the main window's accel table, even if in a text field (5.24+ or so)
    // DEBUG:   int (*translateAccel)(MSG *msg, accelerator_register_t *ctx); 
    // DEBUG:   bool isLocal; // must be TRUE, now (false is no longer supported, heh)
    // DEBUG:   void *user;
    // DEBUG: }
    public ref class AcceleratorRegisterT : ICppInstance
    {
    public:

        property ::accelerator_register_t* NativePtr;
        property System::IntPtr __Instance
        {
            virtual System::IntPtr get();
            virtual void set(System::IntPtr instance);
        }

        AcceleratorRegisterT(::accelerator_register_t* native);
        AcceleratorRegisterT(::accelerator_register_t* native, bool ownNativeInstance);
        static AcceleratorRegisterT^ __CreateInstance(::System::IntPtr native);
        static AcceleratorRegisterT^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
        // DEBUG: accelerator_register_t
        AcceleratorRegisterT();

        // DEBUG: accelerator_register_t
        AcceleratorRegisterT(reaper_plugin_functions::AcceleratorRegisterT^ _0);

        ~AcceleratorRegisterT();

        property reaper_plugin_functions::PCM_source::Func_int___IntPtr___IntPtr^ TranslateAccel
        {
            reaper_plugin_functions::PCM_source::Func_int___IntPtr___IntPtr^ get();
            void set(reaper_plugin_functions::PCM_source::Func_int___IntPtr___IntPtr^);
        }

        property bool IsLocal
        {
            bool get();
            void set(bool);
        }

        property ::System::IntPtr User
        {
            ::System::IntPtr get();
            void set(::System::IntPtr);
        }

    protected:

        bool __ownsNativeInstance;
    };

    // DEBUG: struct
    // DEBUG: {
    // DEBUG:   int uniqueSectionId; // 0/100=main/main alt, 32063=media explorer, 32060=midi editor, 32061=midi event list editor, 32062=midi inline editor, etc
    // DEBUG:   const char* idStr; // must be unique across all sections for actions, NULL for reascripts (automatically generated)
    // DEBUG:   const char* name; // name as it is displayed in the action list, or full path to a reascript file
    // DEBUG:   void *extra; // reserved for future use
    // DEBUG: }
    public ref class CustomActionRegisterT : ICppInstance
    {
    public:

        property ::custom_action_register_t* NativePtr;
        property System::IntPtr __Instance
        {
            virtual System::IntPtr get();
            virtual void set(System::IntPtr instance);
        }

        CustomActionRegisterT(::custom_action_register_t* native);
        CustomActionRegisterT(::custom_action_register_t* native, bool ownNativeInstance);
        static CustomActionRegisterT^ __CreateInstance(::System::IntPtr native);
        static CustomActionRegisterT^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
        // DEBUG: struct
        CustomActionRegisterT();

        // DEBUG: struct
        CustomActionRegisterT(reaper_plugin_functions::CustomActionRegisterT^ __0);

        ~CustomActionRegisterT();

        property int UniqueSectionId
        {
            int get();
            void set(int);
        }

        property System::String^ IdStr
        {
            System::String^ get();
            void set(System::String^);
        }

        property System::String^ Name
        {
            System::String^ get();
            void set(System::String^);
        }

        property ::System::IntPtr Extra
        {
            ::System::IntPtr get();
            void set(::System::IntPtr);
        }

    protected:

        bool __ownsNativeInstance;
    };

    // DEBUG: struct 
    // DEBUG: {
    // DEBUG:   ACCEL accel; // key flags/etc represent default values (user may customize)
    // DEBUG:   const char *desc; // description (for user customizability)
    // DEBUG: }
    public ref class GaccelRegisterT : ICppInstance
    {
    public:

        property ::gaccel_register_t* NativePtr;
        property System::IntPtr __Instance
        {
            virtual System::IntPtr get();
            virtual void set(System::IntPtr instance);
        }

        GaccelRegisterT(::gaccel_register_t* native);
        GaccelRegisterT(::gaccel_register_t* native, bool ownNativeInstance);
        static GaccelRegisterT^ __CreateInstance(::System::IntPtr native);
        static GaccelRegisterT^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
        // DEBUG: struct
        GaccelRegisterT();

        // DEBUG: struct
        GaccelRegisterT(reaper_plugin_functions::GaccelRegisterT^ __0);

        ~GaccelRegisterT();

        property TagACCEL^ Accel
        {
            TagACCEL^ get();
            void set(TagACCEL^);
        }

        property System::String^ Desc
        {
            System::String^ get();
            void set(System::String^);
        }

    protected:

        bool __ownsNativeInstance;
    };

    // DEBUG: struct
    // DEBUG: {
    // DEBUG:   const char* action_desc;
    // DEBUG:   const char* action_help;
    // DEBUG: }
    public ref class ActionHelpT : ICppInstance
    {
    public:

        property ::action_help_t* NativePtr;
        property System::IntPtr __Instance
        {
            virtual System::IntPtr get();
            virtual void set(System::IntPtr instance);
        }

        ActionHelpT(::action_help_t* native);
        ActionHelpT(::action_help_t* native, bool ownNativeInstance);
        static ActionHelpT^ __CreateInstance(::System::IntPtr native);
        static ActionHelpT^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
        // DEBUG: struct
        ActionHelpT();

        // DEBUG: struct
        ActionHelpT(reaper_plugin_functions::ActionHelpT^ __0);

        ~ActionHelpT();

        property System::String^ ActionDesc
        {
            System::String^ get();
            void set(System::String^);
        }

        property System::String^ ActionHelp
        {
            System::String^ get();
            void set(System::String^);
        }

    protected:

        bool __ownsNativeInstance;
    };

    // DEBUG: struct // register with "editor"
    // DEBUG: {
    // DEBUG:   int (*editFile)(const char *filename, HWND parent, int trackidx); // return TRUE if handled for this file
    // DEBUG:   const char *(*wouldHandle)(const char *filename); // return your editor's description string
    // DEBUG: 
    // DEBUG: }
    public ref class EditorRegisterT : ICppInstance
    {
    public:

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate int Func_int_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string___IntPtr_int(System::String^ filename, HWND_^ parent, int trackidx);

        property ::editor_register_t* NativePtr;
        property System::IntPtr __Instance
        {
            virtual System::IntPtr get();
            virtual void set(System::IntPtr instance);
        }

        EditorRegisterT(::editor_register_t* native);
        EditorRegisterT(::editor_register_t* native, bool ownNativeInstance);
        static EditorRegisterT^ __CreateInstance(::System::IntPtr native);
        static EditorRegisterT^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
        // DEBUG: struct
        EditorRegisterT();

        // DEBUG: struct
        EditorRegisterT(reaper_plugin_functions::EditorRegisterT^ __0);

        ~EditorRegisterT();

        property reaper_plugin_functions::EditorRegisterT::Func_int_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string___IntPtr_int^ EditFile
        {
            reaper_plugin_functions::EditorRegisterT::Func_int_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string___IntPtr_int^ get();
            void set(reaper_plugin_functions::EditorRegisterT::Func_int_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string___IntPtr_int^);
        }

        property ::reaper_plugin_functions::Func___IntPtr_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string^ WouldHandle
        {
            ::reaper_plugin_functions::Func___IntPtr_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string^ get();
            void set(::reaper_plugin_functions::Func___IntPtr_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string^);
        }

    protected:

        bool __ownsNativeInstance;
    };

    // DEBUG: struct // register with "projectimport"
    // DEBUG: {
    // DEBUG:   bool (*WantProjectFile)(const char *fn); // is this our file?
    // DEBUG:   const char *(*EnumFileExtensions)(int i, char **descptr); // call increasing i until returns NULL. if descptr's output is NULL, use last description
    // DEBUG:   int (*LoadProject)(const char *fn, ProjectStateContext *genstate); // return 0=ok, Generate RPP compatible project info in genstate
    // DEBUG: }
    public ref class ProjectImportRegisterT : ICppInstance
    {
    public:

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate bool Func_bool_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string(System::String^ fn);

        property ::project_import_register_t* NativePtr;
        property System::IntPtr __Instance
        {
            virtual System::IntPtr get();
            virtual void set(System::IntPtr instance);
        }

        ProjectImportRegisterT(::project_import_register_t* native);
        ProjectImportRegisterT(::project_import_register_t* native, bool ownNativeInstance);
        static ProjectImportRegisterT^ __CreateInstance(::System::IntPtr native);
        static ProjectImportRegisterT^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
        // DEBUG: struct
        ProjectImportRegisterT();

        // DEBUG: struct
        ProjectImportRegisterT(reaper_plugin_functions::ProjectImportRegisterT^ __0);

        ~ProjectImportRegisterT();

        property reaper_plugin_functions::ProjectImportRegisterT::Func_bool_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string^ WantProjectFile
        {
            reaper_plugin_functions::ProjectImportRegisterT::Func_bool_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string^ get();
            void set(reaper_plugin_functions::ProjectImportRegisterT::Func_bool_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string^);
        }

        property reaper_plugin_functions::PcmsrcRegisterT::Func___IntPtr_int_sbytePtrPtr^ EnumFileExtensions
        {
            reaper_plugin_functions::PcmsrcRegisterT::Func___IntPtr_int_sbytePtrPtr^ get();
            void set(reaper_plugin_functions::PcmsrcRegisterT::Func___IntPtr_int_sbytePtrPtr^);
        }

        property reaper_plugin_functions::ReaperPluginInfoT::Func_int_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string___IntPtr^ LoadProject
        {
            reaper_plugin_functions::ReaperPluginInfoT::Func_int_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string___IntPtr^ get();
            void set(reaper_plugin_functions::ReaperPluginInfoT::Func_int_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string___IntPtr^);
        }

    protected:

        bool __ownsNativeInstance;
    };

    // DEBUG: struct project_config_extension_t // register with "projectconfig"
    // DEBUG: {
    // DEBUG:   // plug-ins may or may not want to save their undo states (look at isUndo)
    // DEBUG:   // undo states will be saved if UNDO_STATE_MISCCFG is set (for adding your own undo points)
    // DEBUG:   bool (*ProcessExtensionLine)(const char *line, ProjectStateContext *ctx, bool isUndo, struct project_config_extension_t *reg); // returns BOOL if line (and optionally subsequent lines) processed (return false if not plug-ins line)
    // DEBUG:   void (*SaveExtensionConfig)(ProjectStateContext *ctx, bool isUndo, struct project_config_extension_t *reg);
    // DEBUG: 
    // DEBUG:   // optional: called on project load/undo before any (possible) ProcessExtensionLine. NULL is OK too
    // DEBUG:   // also called on "new project" (wont be followed by ProcessExtensionLine calls in that case)
    // DEBUG:   void (*BeginLoadProjectState)(bool isUndo, struct project_config_extension_t *reg); 
    // DEBUG: 
    // DEBUG:   void *userData;
    // DEBUG: }
    public ref class ProjectConfigExtensionT : ICppInstance
    {
    public:

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate bool Func_bool_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string___IntPtr_bool___IntPtr(System::String^ line, reaper_plugin_functions::ProjectStateContext^ ctx, bool isUndo, reaper_plugin_functions::ProjectConfigExtensionT^ reg);

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate void Action___IntPtr_bool___IntPtr(reaper_plugin_functions::ProjectStateContext^ ctx, bool isUndo, reaper_plugin_functions::ProjectConfigExtensionT^ reg);

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate void Action_bool___IntPtr(bool isUndo, reaper_plugin_functions::ProjectConfigExtensionT^ reg);

        property ::project_config_extension_t* NativePtr;
        property System::IntPtr __Instance
        {
            virtual System::IntPtr get();
            virtual void set(System::IntPtr instance);
        }

        ProjectConfigExtensionT(::project_config_extension_t* native);
        ProjectConfigExtensionT(::project_config_extension_t* native, bool ownNativeInstance);
        static ProjectConfigExtensionT^ __CreateInstance(::System::IntPtr native);
        static ProjectConfigExtensionT^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
        // DEBUG: project_config_extension_t
        ProjectConfigExtensionT();

        // DEBUG: project_config_extension_t
        ProjectConfigExtensionT(reaper_plugin_functions::ProjectConfigExtensionT^ _0);

        ~ProjectConfigExtensionT();

        property reaper_plugin_functions::ProjectConfigExtensionT::Func_bool_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string___IntPtr_bool___IntPtr^ ProcessExtensionLine
        {
            reaper_plugin_functions::ProjectConfigExtensionT::Func_bool_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string___IntPtr_bool___IntPtr^ get();
            void set(reaper_plugin_functions::ProjectConfigExtensionT::Func_bool_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string___IntPtr_bool___IntPtr^);
        }

        property reaper_plugin_functions::ProjectConfigExtensionT::Action___IntPtr_bool___IntPtr^ SaveExtensionConfig
        {
            reaper_plugin_functions::ProjectConfigExtensionT::Action___IntPtr_bool___IntPtr^ get();
            void set(reaper_plugin_functions::ProjectConfigExtensionT::Action___IntPtr_bool___IntPtr^);
        }

        property reaper_plugin_functions::ProjectConfigExtensionT::Action_bool___IntPtr^ BeginLoadProjectState
        {
            reaper_plugin_functions::ProjectConfigExtensionT::Action_bool___IntPtr^ get();
            void set(reaper_plugin_functions::ProjectConfigExtensionT::Action_bool___IntPtr^);
        }

        property ::System::IntPtr UserData
        {
            ::System::IntPtr get();
            void set(::System::IntPtr);
        }

    protected:

        bool __ownsNativeInstance;
    };

    // DEBUG: struct prefs_page_register_t // register useing "prefpage"
    // DEBUG: {
    // DEBUG:   const char *idstr; // simple id str
    // DEBUG:   const char *displayname;
    // DEBUG:   HWND (*create)(HWND par);
    // DEBUG:   int par_id; 
    // DEBUG:   const char *par_idstr;
    // DEBUG: 
    // DEBUG:   int childrenFlag; // 1 for will have children
    // DEBUG: 
    // DEBUG:   void *treeitem;
    // DEBUG:   HWND hwndCache;
    // DEBUG: 
    // DEBUG:   char _extra[64]; // 
    // DEBUG: 
    // DEBUG: }
    public ref class PrefsPageRegisterT : ICppInstance
    {
    public:

        property ::prefs_page_register_t* NativePtr;
        property System::IntPtr __Instance
        {
            virtual System::IntPtr get();
            virtual void set(System::IntPtr instance);
        }

        PrefsPageRegisterT(::prefs_page_register_t* native);
        PrefsPageRegisterT(::prefs_page_register_t* native, bool ownNativeInstance);
        static PrefsPageRegisterT^ __CreateInstance(::System::IntPtr native);
        static PrefsPageRegisterT^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
        // DEBUG: prefs_page_register_t
        PrefsPageRegisterT();

        // DEBUG: prefs_page_register_t
        PrefsPageRegisterT(reaper_plugin_functions::PrefsPageRegisterT^ _0);

        ~PrefsPageRegisterT();

        property System::String^ Idstr
        {
            System::String^ get();
            void set(System::String^);
        }

        property System::String^ Displayname
        {
            System::String^ get();
            void set(System::String^);
        }

        property reaper_plugin_functions::MidiInput::Func___IntPtr___IntPtr^ Create
        {
            reaper_plugin_functions::MidiInput::Func___IntPtr___IntPtr^ get();
            void set(reaper_plugin_functions::MidiInput::Func___IntPtr___IntPtr^);
        }

        property int ParId
        {
            int get();
            void set(int);
        }

        property System::String^ ParIdstr
        {
            System::String^ get();
            void set(System::String^);
        }

        property int ChildrenFlag
        {
            int get();
            void set(int);
        }

        property ::System::IntPtr Treeitem
        {
            ::System::IntPtr get();
            void set(::System::IntPtr);
        }

        property HWND_^ HwndCache
        {
            HWND_^ get();
            void set(HWND_^);
        }

        property cli::array<char>^ Extra
        {
            cli::array<char>^ get();
            void set(cli::array<char>^);
        }

    protected:

        bool __ownsNativeInstance;
    };

    // DEBUG: struct audio_hook_register_t
    // DEBUG: {
    // DEBUG:   void (*OnAudioBuffer)(bool isPost, int len, double srate, struct audio_hook_register_t *reg); // called twice per frame, isPost being false then true
    // DEBUG:   void *userdata1;
    // DEBUG:   void *userdata2;
    // DEBUG: 
    // DEBUG:   // plug-in should zero these and they will be set by host
    // DEBUG:   // only call from OnAudioBuffer, nowhere else!!!
    // DEBUG:   int input_nch, output_nch; 
    // DEBUG:   ReaSample *(*GetBuffer)(bool isOutput, int idx); 
    // DEBUG: 
    // DEBUG: }
    public ref class AudioHookRegisterT : ICppInstance
    {
    public:

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate void Action_bool_int_double___IntPtr(bool isPost, int len, double srate, reaper_plugin_functions::AudioHookRegisterT^ reg);

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate double* Func_doublePtr_bool_int(bool isOutput, int idx);

        property ::audio_hook_register_t* NativePtr;
        property System::IntPtr __Instance
        {
            virtual System::IntPtr get();
            virtual void set(System::IntPtr instance);
        }

        AudioHookRegisterT(::audio_hook_register_t* native);
        AudioHookRegisterT(::audio_hook_register_t* native, bool ownNativeInstance);
        static AudioHookRegisterT^ __CreateInstance(::System::IntPtr native);
        static AudioHookRegisterT^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
        // DEBUG: audio_hook_register_t
        AudioHookRegisterT();

        // DEBUG: audio_hook_register_t
        AudioHookRegisterT(reaper_plugin_functions::AudioHookRegisterT^ _0);

        ~AudioHookRegisterT();

        property reaper_plugin_functions::AudioHookRegisterT::Action_bool_int_double___IntPtr^ OnAudioBuffer
        {
            reaper_plugin_functions::AudioHookRegisterT::Action_bool_int_double___IntPtr^ get();
            void set(reaper_plugin_functions::AudioHookRegisterT::Action_bool_int_double___IntPtr^);
        }

        property ::System::IntPtr Userdata1
        {
            ::System::IntPtr get();
            void set(::System::IntPtr);
        }

        property ::System::IntPtr Userdata2
        {
            ::System::IntPtr get();
            void set(::System::IntPtr);
        }

        property int InputNch
        {
            int get();
            void set(int);
        }

        property int OutputNch
        {
            int get();
            void set(int);
        }

        property reaper_plugin_functions::AudioHookRegisterT::Func_doublePtr_bool_int^ GetBuffer
        {
            reaper_plugin_functions::AudioHookRegisterT::Func_doublePtr_bool_int^ get();
            void set(reaper_plugin_functions::AudioHookRegisterT::Func_doublePtr_bool_int^);
        }

    protected:

        bool __ownsNativeInstance;
    };

    // DEBUG: struct  
    // DEBUG: {
    // DEBUG:   DWORD cmd;  // action command ID
    // DEBUG:   const char *text; // description of action
    // DEBUG: }
    public ref class KbdCmd : ICppInstance
    {
    public:

        property ::KbdCmd* NativePtr;
        property System::IntPtr __Instance
        {
            virtual System::IntPtr get();
            virtual void set(System::IntPtr instance);
        }

        KbdCmd(::KbdCmd* native);
        KbdCmd(::KbdCmd* native, bool ownNativeInstance);
        static KbdCmd^ __CreateInstance(::System::IntPtr native);
        static KbdCmd^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
        // DEBUG: struct
        KbdCmd();

        // DEBUG: struct
        KbdCmd(reaper_plugin_functions::KbdCmd^ __0);

        ~KbdCmd();

        property unsigned long Cmd
        {
            unsigned long get();
            void set(unsigned long);
        }

        property System::String^ Text
        {
            System::String^ get();
            void set(System::String^);
        }

    protected:

        bool __ownsNativeInstance;
    };

    // DEBUG: struct
    // DEBUG: {
    // DEBUG:   int key;  // key identifier
    // DEBUG:   int cmd;  // action command ID
    // DEBUG:   int flags; // key flags
    // DEBUG: }
    public ref class KbdKeyBindingInfo : ICppInstance
    {
    public:

        property ::KbdKeyBindingInfo* NativePtr;
        property System::IntPtr __Instance
        {
            virtual System::IntPtr get();
            virtual void set(System::IntPtr instance);
        }

        KbdKeyBindingInfo(::KbdKeyBindingInfo* native);
        KbdKeyBindingInfo(::KbdKeyBindingInfo* native, bool ownNativeInstance);
        static KbdKeyBindingInfo^ __CreateInstance(::System::IntPtr native);
        static KbdKeyBindingInfo^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
        // DEBUG: struct
        KbdKeyBindingInfo();

        // DEBUG: struct
        KbdKeyBindingInfo(reaper_plugin_functions::KbdKeyBindingInfo^ __0);

        ~KbdKeyBindingInfo();

        property int Key
        {
            int get();
            void set(int);
        }

        property int Cmd
        {
            int get();
            void set(int);
        }

        property int Flags
        {
            int get();
            void set(int);
        }

    protected:

        bool __ownsNativeInstance;
    };

    // DEBUG: struct
    // DEBUG: {
    // DEBUG:   int uniqueID; // 0=main, < 0x10000000 for cockos use only plzkthx
    // DEBUG:   const char *name; // section name
    // DEBUG: 
    // DEBUG:   KbdCmd *action_list;   // list of assignable actions
    // DEBUG:   int action_list_cnt;
    // DEBUG: 
    // DEBUG:   KbdKeyBindingInfo *def_keys; // list of default key bindings
    // DEBUG:   int def_keys_cnt;
    // DEBUG: 
    // DEBUG:   // hwnd is 0 if MIDI etc. return false if ignoring
    // DEBUG:   bool (*onAction)(int cmd, int val, int valhw, int relmode, HWND hwnd);
    // DEBUG: 
    // DEBUG:   // this is allocated by the host not by the plug-in using it
    // DEBUG:   // the user can edit the list of actions/macros
    // DEBUG: #ifdef _WDL_PTRLIST_H_
    // DEBUG:   WDL_PtrList<struct KbdAccel> *accels;  
    // DEBUG:   WDL_TypedBuf<int>* recent_cmds;
    // DEBUG: #else
    // DEBUG:   void* accels;
    // DEBUG:   void *recent_cmds;
    // DEBUG: #endif
    // DEBUG: 
    // DEBUG:   void *extended_data[32]; // for internal use
    // DEBUG: }
    public ref class KbdSectionInfo : ICppInstance
    {
    public:

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate bool Func_bool_int_int_int_int___IntPtr(int cmd, int val, int valhw, int relmode, HWND_^ hwnd);

        property ::KbdSectionInfo* NativePtr;
        property System::IntPtr __Instance
        {
            virtual System::IntPtr get();
            virtual void set(System::IntPtr instance);
        }

        KbdSectionInfo(::KbdSectionInfo* native);
        KbdSectionInfo(::KbdSectionInfo* native, bool ownNativeInstance);
        static KbdSectionInfo^ __CreateInstance(::System::IntPtr native);
        static KbdSectionInfo^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
        // DEBUG: struct
        KbdSectionInfo();

        // DEBUG: struct
        KbdSectionInfo(reaper_plugin_functions::KbdSectionInfo^ __0);

        ~KbdSectionInfo();

        property int UniqueID
        {
            int get();
            void set(int);
        }

        property System::String^ Name
        {
            System::String^ get();
            void set(System::String^);
        }

        property reaper_plugin_functions::KbdCmd^ ActionList
        {
            reaper_plugin_functions::KbdCmd^ get();
            void set(reaper_plugin_functions::KbdCmd^);
        }

        property int ActionListCnt
        {
            int get();
            void set(int);
        }

        property reaper_plugin_functions::KbdKeyBindingInfo^ DefKeys
        {
            reaper_plugin_functions::KbdKeyBindingInfo^ get();
            void set(reaper_plugin_functions::KbdKeyBindingInfo^);
        }

        property int DefKeysCnt
        {
            int get();
            void set(int);
        }

        property reaper_plugin_functions::KbdSectionInfo::Func_bool_int_int_int_int___IntPtr^ OnAction
        {
            reaper_plugin_functions::KbdSectionInfo::Func_bool_int_int_int_int___IntPtr^ get();
            void set(reaper_plugin_functions::KbdSectionInfo::Func_bool_int_int_int_int___IntPtr^);
        }

        property ::System::IntPtr Accels
        {
            ::System::IntPtr get();
            void set(::System::IntPtr);
        }

        property ::System::IntPtr RecentCmds
        {
            ::System::IntPtr get();
            void set(::System::IntPtr);
        }

        property cli::array<::System::IntPtr>^ ExtendedData
        {
            cli::array<::System::IntPtr>^ get();
            void set(cli::array<::System::IntPtr>^);
        }

    protected:

        bool __ownsNativeInstance;
    };

    // DEBUG: struct
    // DEBUG: {
    // DEBUG: /*
    // DEBUG: ** Note: you must initialize/deinitialize the cs/mutex (depending on OS) manually, and use it if accessing most parameters while the preview is active.
    // DEBUG: */
    // DEBUG: 
    // DEBUG: #ifdef _WIN32
    // DEBUG:   CRITICAL_SECTION cs;
    // DEBUG: #else
    // DEBUG:   pthread_mutex_t mutex;
    // DEBUG: #endif
    // DEBUG:   PCM_source *src;
    // DEBUG:   int m_out_chan; // &1024 means mono, low 10 bits are index of first channel
    // DEBUG:   double curpos;
    // DEBUG:   bool loop;
    // DEBUG:   double volume;
    // DEBUG: 
    // DEBUG:   double peakvol[2];
    // DEBUG:   void *preview_track; // used for track previews, but only if m_out_chan == -1
    // DEBUG: }
    public ref class PreviewRegisterT : ICppInstance
    {
    public:

        property ::preview_register_t* NativePtr;
        property System::IntPtr __Instance
        {
            virtual System::IntPtr get();
            virtual void set(System::IntPtr instance);
        }

        PreviewRegisterT(::preview_register_t* native);
        PreviewRegisterT(::preview_register_t* native, bool ownNativeInstance);
        static PreviewRegisterT^ __CreateInstance(::System::IntPtr native);
        static PreviewRegisterT^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
        // DEBUG: struct
        PreviewRegisterT();

        // DEBUG: struct
        PreviewRegisterT(reaper_plugin_functions::PreviewRegisterT^ __0);

        ~PreviewRegisterT();

        property RTL_CRITICAL_SECTION^ Cs
        {
            RTL_CRITICAL_SECTION^ get();
            void set(RTL_CRITICAL_SECTION^);
        }

        property reaper_plugin_functions::PCM_source^ Src
        {
            reaper_plugin_functions::PCM_source^ get();
            void set(reaper_plugin_functions::PCM_source^);
        }

        property int MOutChan
        {
            int get();
            void set(int);
        }

        property double Curpos
        {
            double get();
            void set(double);
        }

        property bool Loop
        {
            bool get();
            void set(bool);
        }

        property double Volume
        {
            double get();
            void set(double);
        }

        property cli::array<double>^ Peakvol
        {
            cli::array<double>^ get();
            void set(cli::array<double>^);
        }

        property ::System::IntPtr PreviewTrack
        {
            ::System::IntPtr get();
            void set(::System::IntPtr);
        }

    protected:

        bool __ownsNativeInstance;
    };

    // DEBUG: class midi_Output
    // DEBUG: {
    // DEBUG: public:
    // DEBUG:   virtual ~midi_Output() {}
    // DEBUG: 
    // DEBUG:   virtual void BeginBlock() { }  // outputs can implement these if they wish to have timed block sends
    // DEBUG:   virtual void EndBlock(int length, double srate, double curtempo) { }
    // DEBUG:   virtual void SendMsg(MIDI_event_t *msg, int frame_offset)=0; // frame_offset can be <0 for "instant" if supported
    // DEBUG:   virtual void Send(unsigned char status, unsigned char d1, unsigned char d2, int frame_offset)=0; // frame_offset can be <0 for "instant" if supported
    // DEBUG: 
    // DEBUG:   virtual void Destroy() { delete this; } // allows implementations to do asynchronous destroy (5.95+)
    // DEBUG: 
    // DEBUG: }
    public ref class MidiOutput : ICppInstance
    {
    public:

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate void Action___IntPtr_int_double_double(::System::IntPtr __instance, int arg1, double arg2, double arg3);

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate void Action___IntPtr___IntPtr_int(::System::IntPtr __instance, reaper_plugin_functions::MIDI_event_t^ arg1, int arg2);

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate void Action___IntPtr_byte_byte_byte_int(::System::IntPtr __instance, unsigned char arg1, unsigned char arg2, unsigned char arg3, int arg4);

        property ::midi_Output* NativePtr;
        property System::IntPtr __Instance
        {
            virtual System::IntPtr get();
            virtual void set(System::IntPtr instance);
        }

        MidiOutput(::midi_Output* native);
        MidiOutput(::midi_Output* native, bool ownNativeInstance);
        static MidiOutput^ __CreateInstance(::System::IntPtr native);
        static MidiOutput^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
        // DEBUG: midi_Output
        MidiOutput();

        // DEBUG: midi_Output
        MidiOutput(reaper_plugin_functions::MidiOutput^ _0);

        ~MidiOutput();

        // DEBUG: virtual void BeginBlock() { }
        virtual void BeginBlock();

        // DEBUG: virtual void EndBlock(int length, double srate, double curtempo) { }
        virtual void EndBlock(int length, double srate, double curtempo);

        // DEBUG: virtual void SendMsg(MIDI_event_t *msg, int frame_offset)=0
        virtual void SendMsg(reaper_plugin_functions::MIDI_event_t^ msg, int frame_offset);

        // DEBUG: virtual void Send(unsigned char status, unsigned char d1, unsigned char d2, int frame_offset)=0
        virtual void Send(unsigned char status, unsigned char d1, unsigned char d2, int frame_offset);

        // DEBUG: virtual void Destroy() { delete this; }
        virtual void Destroy();

    protected:

        bool __ownsNativeInstance;
    };

    // DEBUG: class midi_Input
    // DEBUG: {
    // DEBUG: public:
    // DEBUG:   virtual ~midi_Input() {}
    // DEBUG: 
    // DEBUG:   virtual void start()=0;
    // DEBUG:   virtual void stop()=0;
    // DEBUG: 
    // DEBUG:   virtual void SwapBufs(unsigned int timestamp)=0; // DEPRECATED call SwapBufsPrecise() instead  // timestamp=process ms
    // DEBUG: 
    // DEBUG:   virtual void RunPreNoteTracking(int isAccum) { }
    // DEBUG: 
    // DEBUG:   virtual MIDI_eventlist *GetReadBuf()=0; // note: the event list here has frame offsets that are in units of 1/1024000 of a second, NOT sample frames
    // DEBUG: 
    // DEBUG:   virtual void SwapBufsPrecise(unsigned int coarsetimestamp, double precisetimestamp) // coarse=process ms, precise=process sec, the target will know internally which to use
    // DEBUG:   {
    // DEBUG:     SwapBufs(coarsetimestamp);  // default impl is for backward compatibility
    // DEBUG:   }
    // DEBUG: 
    // DEBUG:   virtual void Destroy() { delete this; } // allows implementations to do asynchronous destroy (5.95+)
    // DEBUG: }
    public ref class MidiInput : ICppInstance
    {
    public:

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate void Action___IntPtr(::System::IntPtr __instance);

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate void Action___IntPtr_uint(::System::IntPtr __instance, unsigned int arg1);

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate void Action___IntPtr_int(::System::IntPtr __instance, int arg1);

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate reaper_plugin_functions::MIDI_eventlist^ Func___IntPtr___IntPtr(::System::IntPtr __instance);

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate void Action___IntPtr_uint_double(::System::IntPtr __instance, unsigned int arg1, double arg2);

        property ::midi_Input* NativePtr;
        property System::IntPtr __Instance
        {
            virtual System::IntPtr get();
            virtual void set(System::IntPtr instance);
        }

        MidiInput(::midi_Input* native);
        MidiInput(::midi_Input* native, bool ownNativeInstance);
        static MidiInput^ __CreateInstance(::System::IntPtr native);
        static MidiInput^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
        // DEBUG: midi_Input
        MidiInput();

        // DEBUG: midi_Input
        MidiInput(reaper_plugin_functions::MidiInput^ _0);

        ~MidiInput();

        property reaper_plugin_functions::MIDI_eventlist^ ReadBuf
        {
            reaper_plugin_functions::MIDI_eventlist^ get();
        }

        // DEBUG: virtual void start()=0
        virtual void Start();

        // DEBUG: virtual void stop()=0
        virtual void Stop();

        // DEBUG: virtual void SwapBufs(unsigned int timestamp)=0
        virtual void SwapBufs(unsigned int timestamp);

        // DEBUG: virtual void RunPreNoteTracking(int isAccum) { }
        virtual void RunPreNoteTracking(int isAccum);

        // DEBUG: virtual void SwapBufsPrecise(unsigned int coarsetimestamp, double precisetimestamp) // coarse=process ms, precise=process sec, the target will know internally which to use
        // DEBUG:   {
        // DEBUG:     SwapBufs(coarsetimestamp);  // default impl is for backward compatibility
        // DEBUG:   }
        virtual void SwapBufsPrecise(unsigned int coarsetimestamp, double precisetimestamp);

        // DEBUG: virtual void Destroy() { delete this; }
        virtual void Destroy();

    protected:

        bool __ownsNativeInstance;
    };

    // DEBUG: class IReaperControlSurface
    // DEBUG: {
    // DEBUG:   public:
    // DEBUG:     IReaperControlSurface() { }
    // DEBUG:     virtual ~IReaperControlSurface() { }
    // DEBUG:     
    // DEBUG:     virtual const char *GetTypeString()=0; // simple unique string with only A-Z, 0-9, no spaces or other chars
    // DEBUG:     virtual const char *GetDescString()=0; // human readable description (can include instance specific info)
    // DEBUG:     virtual const char *GetConfigString()=0; // string of configuration data
    // DEBUG: 
    // DEBUG:     virtual void CloseNoReset() { } // close without sending "reset" messages, prevent "reset" being sent on destructor
    // DEBUG: 
    // DEBUG: 
    // DEBUG:     virtual void Run() { } // called 30x/sec or so.
    // DEBUG: 
    // DEBUG: 
    // DEBUG:     // these will be called by the host when states change etc
    // DEBUG:     virtual void SetTrackListChange() { }
    // DEBUG:     virtual void SetSurfaceVolume(MediaTrack *trackid, double volume) { }
    // DEBUG:     virtual void SetSurfacePan(MediaTrack *trackid, double pan) { }
    // DEBUG:     virtual void SetSurfaceMute(MediaTrack *trackid, bool mute) { }
    // DEBUG:     virtual void SetSurfaceSelected(MediaTrack *trackid, bool selected) { }
    // DEBUG:     virtual void SetSurfaceSolo(MediaTrack *trackid, bool solo) { } // trackid==master means "any solo"
    // DEBUG:     virtual void SetSurfaceRecArm(MediaTrack *trackid, bool recarm) { }
    // DEBUG:     virtual void SetPlayState(bool play, bool pause, bool rec) { }
    // DEBUG:     virtual void SetRepeatState(bool rep) { }
    // DEBUG:     virtual void SetTrackTitle(MediaTrack *trackid, const char *title) { }
    // DEBUG:     virtual bool GetTouchState(MediaTrack *trackid, int isPan) { return false; }
    // DEBUG:     virtual void SetAutoMode(int mode) { } // automation mode for current track
    // DEBUG: 
    // DEBUG:     virtual void ResetCachedVolPanStates() { } // good to flush your control states here
    // DEBUG: 
    // DEBUG:     virtual void OnTrackSelection(MediaTrack *trackid) { } // track was selected
    // DEBUG:     
    // DEBUG:     virtual bool IsKeyDown(int key) { return false; } // VK_CONTROL, VK_MENU, VK_SHIFT, etc, whatever makes sense for your surface
    // DEBUG: 
    // DEBUG:     virtual int Extended(int call, void *parm1, void *parm2, void *parm3) { return 0; } // return 0 if unsupported
    // DEBUG: }
    public ref class IReaperControlSurface : ICppInstance
    {
    public:

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate void Action___IntPtr___IntPtr_double(::System::IntPtr __instance, reaper_plugin_functions::MediaTrack^ arg1, double arg2);

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate void Action___IntPtr___IntPtr_bool(::System::IntPtr __instance, reaper_plugin_functions::MediaTrack^ arg1, bool arg2);

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate void Action___IntPtr_bool_bool_bool(::System::IntPtr __instance, bool arg1, bool arg2, bool arg3);

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate void Action___IntPtr___IntPtr_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string(::System::IntPtr __instance, reaper_plugin_functions::MediaTrack^ arg1, System::String^ arg2);

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate bool Func_bool___IntPtr___IntPtr_int(::System::IntPtr __instance, reaper_plugin_functions::MediaTrack^ arg1, int arg2);

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate bool Func_bool___IntPtr_int(::System::IntPtr __instance, int arg1);

        property ::IReaperControlSurface* NativePtr;
        property System::IntPtr __Instance
        {
            virtual System::IntPtr get();
            virtual void set(System::IntPtr instance);
        }

        IReaperControlSurface(::IReaperControlSurface* native);
        IReaperControlSurface(::IReaperControlSurface* native, bool ownNativeInstance);
        static IReaperControlSurface^ __CreateInstance(::System::IntPtr native);
        static IReaperControlSurface^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
        // DEBUG: IReaperControlSurface() { }
        IReaperControlSurface();

        // DEBUG: IReaperControlSurface
        IReaperControlSurface(reaper_plugin_functions::IReaperControlSurface^ _0);

        ~IReaperControlSurface();

        property System::String^ TypeString
        {
            System::String^ get();
        }

        property System::String^ DescString
        {
            System::String^ get();
        }

        property System::String^ ConfigString
        {
            System::String^ get();
        }

        // DEBUG: virtual void CloseNoReset() { }
        virtual void CloseNoReset();

        // DEBUG: virtual void Run() { }
        virtual void Run();

        // DEBUG: virtual void SetTrackListChange() { }
        virtual void SetTrackListChange();

        // DEBUG: virtual void SetPlayState(bool play, bool pause, bool rec) { }
        virtual void SetPlayState(bool play, bool pause, bool rec);

        // DEBUG: virtual void SetRepeatState(bool rep) { }
        virtual void SetRepeatState(bool rep);

        // DEBUG: virtual void SetAutoMode(int mode) { }
        virtual void SetAutoMode(int mode);

        // DEBUG: virtual void ResetCachedVolPanStates() { }
        virtual void ResetCachedVolPanStates();

        // DEBUG: virtual bool IsKeyDown(int key) { return false; }
        virtual bool IsKeyDown(int key);

        // DEBUG: virtual int Extended(int call, void *parm1, void *parm2, void *parm3) { return 0; }
        virtual int Extended(int call, ::System::IntPtr parm1, ::System::IntPtr parm2, ::System::IntPtr parm3);

    protected:

        bool __ownsNativeInstance;
    };

    // DEBUG: struct
    // DEBUG: {
    // DEBUG:   const char *type_string; // simple unique string with only A-Z, 0-9, no spaces or other chars
    // DEBUG:   const char *desc_string; // human readable description
    // DEBUG: 
    // DEBUG:   IReaperControlSurface *(*create)(const char *type_string, const char *configString, int *errStats); // errstats gets |1 if input error, |2 if output error
    // DEBUG:   HWND (*ShowConfig)(const char *type_string, HWND parent, const char *initConfigString); 
    // DEBUG: }
    public ref class ReaperCsurfRegT : ICppInstance
    {
    public:

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate reaper_plugin_functions::IReaperControlSurface^ Func___IntPtr_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string_intPtr(System::String^ type_string, System::String^ configString, int* errStats);

        [System::Runtime::InteropServices::UnmanagedFunctionPointer(System::Runtime::InteropServices::CallingConvention::Cdecl)] 
        delegate HWND_^ Func___IntPtr_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string___IntPtr_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string(System::String^ type_string, HWND_^ parent, System::String^ initConfigString);

        property ::reaper_csurf_reg_t* NativePtr;
        property System::IntPtr __Instance
        {
            virtual System::IntPtr get();
            virtual void set(System::IntPtr instance);
        }

        ReaperCsurfRegT(::reaper_csurf_reg_t* native);
        ReaperCsurfRegT(::reaper_csurf_reg_t* native, bool ownNativeInstance);
        static ReaperCsurfRegT^ __CreateInstance(::System::IntPtr native);
        static ReaperCsurfRegT^ __CreateInstance(::System::IntPtr native, bool __ownsNativeInstance);
        // DEBUG: struct
        ReaperCsurfRegT();

        // DEBUG: struct
        ReaperCsurfRegT(reaper_plugin_functions::ReaperCsurfRegT^ __0);

        ~ReaperCsurfRegT();

        property System::String^ TypeString
        {
            System::String^ get();
            void set(System::String^);
        }

        property System::String^ DescString
        {
            System::String^ get();
            void set(System::String^);
        }

        property reaper_plugin_functions::ReaperCsurfRegT::Func___IntPtr_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string_intPtr^ Create
        {
            reaper_plugin_functions::ReaperCsurfRegT::Func___IntPtr_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string_intPtr^ get();
            void set(reaper_plugin_functions::ReaperCsurfRegT::Func___IntPtr_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string_intPtr^);
        }

        property reaper_plugin_functions::ReaperCsurfRegT::Func___IntPtr_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string___IntPtr_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string^ ShowConfig
        {
            reaper_plugin_functions::ReaperCsurfRegT::Func___IntPtr_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string___IntPtr_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string^ get();
            void set(reaper_plugin_functions::ReaperCsurfRegT::Func___IntPtr_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string___IntPtr_[MarshalAs(UnmanagedType_CustomMarshaler,_MarshalTypeRef_=_typeof(CppSharp_Runtime_UTF8Marshaller))]_string^);
        }

    protected:

        bool __ownsNativeInstance;
    };

    public ref class reaper_plugin
    {
    public:
        // DEBUG: static int REAPER_BSWAPINT(int x)
        // DEBUG: {
        // DEBUG:   return ((((x))&0xff)<<24)|((((x))&0xff00)<<8)|((((x))&0xff0000)>>8)|(((x)>>24)&0xff);
        // DEBUG: }
        static int REAPER_BSWAPINT(int x);
        // DEBUG: static void REAPER_BSWAPINTMEM(void *buf)
        // DEBUG: {
        // DEBUG:   char *p=(char *)buf;
        // DEBUG:   char tmp=p[0]; p[0]=p[3]; p[3]=tmp;
        // DEBUG:   tmp=p[1]; p[1]=p[2]; p[2]=tmp;
        // DEBUG: }
        static void REAPER_BSWAPINTMEM(::System::IntPtr buf);
        // DEBUG: static void REAPER_BSWAPINTMEM8(void *buf)
        // DEBUG: {
        // DEBUG:   char *p=(char *)buf;
        // DEBUG:   char tmp=p[0]; p[0]=p[7]; p[7]=tmp;
        // DEBUG:   tmp=p[1]; p[1]=p[6]; p[6]=tmp;
        // DEBUG:   tmp=p[2]; p[2]=p[5]; p[5]=tmp;
        // DEBUG:   tmp=p[3]; p[3]=p[4]; p[4]=tmp;
        // DEBUG: }
        static void REAPER_BSWAPINTMEM8(::System::IntPtr buf);
    };
}
